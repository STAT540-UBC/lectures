---
title: "Gene set enrichment and Network analysis"
author: "Yongjin Park"
date: "`r format(Sys.time(), '%d %B, %Y')`"
classoption: "aspectratio=169"
output:
    powerpoint_presentation:
        reference_doc: "_template.pptx"
    html_document:
        self_contained: true
    beamer_presentation:
        theme: "CambridgeUS"
        colortheme: "seahorse"
        keep_tex: true
        latex_engine: xelatex
header-includes:
  - \AtBeginSection[]{\begin{frame}\frametitle{What you will learn}\tableofcontents[currentsection]\end{frame}}
  - | 
    \makeatletter
    \def\ps@titlepage{%
      \setbeamertemplate{footline}{}
    }
    \addtobeamertemplate{title page}{\thispagestyle{titlepage}}{}
    \makeatother
    \include{toc}
---

```{r setup, include=FALSE}
library(tidyverse)
library(data.table)
library(patchwork)
source("Util.R")
source("Setup.R")
fig.dir <- "Fig/network/"
setup.env(fig.dir)
dir.create("Data", showWarnings=FALSE)
```

## What's next after differential expression analysis?

:::::: {.columns}
::: {.column width=.7}

:::
::: {.column width=.3}

* Differential expression analysis of ~20k genes identified tens or
  hundreds of significant genes

* Can we evaluate our findings from a systems biology perspective?

:::
::::::


# Gene Set Enrichment Analysis

## What is Gene Set Analysis?

:::::: {.columns}
::: {.column width=.45}


### (Discrete) Gene Set Analysis

Input:

1. A dictionary of gene sets that map genes to sets (gene to gene set mapping)
	
2. A list of **top** XX number of genes identified in our own study (after FDR control)

:::
::: {.column width=.45}


### (Rank-based) Gene Set Enrichment

Input:

1. A dictionary of gene sets that map genes to sets
	
2. A **full** list of gene-level **scores** (e.g., p-values, z-scores)

:::
::::::

Output: A table of scores for all the gene sets in the dictionary.


## What have we learned from our differential expression analysis?

```{r results="asis", out.width=".6\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_1.pdf")
```

\hfill $\to$ **coloured:** some pathway of interest

## Let's drop the edges in biological networks

Prior Knowledge of biological pathways define a set of genes (coloured)

```{r results="asis", out.width=".6\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_2.pdf")
```

## Does this pathway overlap with our DEG list?

```{r results="asis", out.width=".6\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_3.pdf")
```

## Say that we found $q$ genes are overlapping with this pathway

```{r results="asis", out.width=".6\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_4.pdf")
```

## Gene Set Analysis testing over-representation of DEGs

:::::: {.columns}
::: {.column width=.5}

```{r results="asis", out.width=".95\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_5.pdf")
```

:::
::: {.column width=.4}

### What are the numbers to count?

* $N$: \# genes in this universe

* $m$: \# genes in this set

* $n$: \# genes *not* in this gene set

* $k$: \# DEGs in our analysis

* $q$: \# DEGs (of $k$) overlapping with the set of $m$ genes

:::
::::::

## Is this overlap of $q=6$ of $k=8$ genes significant?

:::::: {.columns}
::: {.column width=.5}

```{r results="asis", out.width=".95\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_5.pdf")
```

:::
::: {.column width=.4}

* $N = 24$ # a total of 24 genes

* $m = 9$ genes in this set

* $n = N - m = 15$

* $k = 8$ DEGs

* $q=6$ out of $k=8$ overlap

:::
::::::

## Is this overlap of $q=6$ of $k=8$ genes significant?

:::::: {.columns}
::: {.column width=.5}

```{r results="asis", out.width=".95\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_5.pdf")
```

:::
::: {.column width=.4}

Questions:

* Is it meaningful enough to report?

* Is it surprising enough that we recapitulated 6/9 (~`r round(6/9*100)` %)?

* What is the null distribution?

* What is the generative/simulation scheme?

:::
::::::

## How do we find $q$ out of $k$ DEGs overlapping with a gene set of $m$ genes?

:::::: {.columns}
::: {.column width=.45}

```{r results="asis", out.width=".95\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_5.pdf")
```

:::
::: {.column width=.5}

### Under the null of hypergeometric distribution

1. Sample $k$ DEGs out of $N$ genes

2. Of these $k$ genes, $q$ overlap with a gene set consisting of $m$ genes

3. The rest $k-q$ genes overlap with genes outside of the gene set $N-m$

:::
::::::


## *Review of binomial coefficient*: Let's see if we can estimate the null distribution by counting

* How many all possible ways to select $k=8$ out of $N=24$ genes, ignoring the order of $k$ selected genes and $N-k$ *not* selected genes?

* We can think of this as three steps: (1) enumerating $N$ genes, (2) partition them into the first $k$ genes and the rest, (3) ignore the order within each partition.

$${24 \choose 8} = \frac{
	\textsf{\{all possible ways to enumerate }24 \textsf{ genes}\}
	}{
		\{ \textsf{enumerating }8 \textsf{ genes} \}
		\{ \textsf{enumerating }16 \textsf{ genes} \}
}
= \frac{24!}{8! 16!}$$

## Hypergeometric distribution

1. What is the probability of selecting $k$ DEGs out of $N$ genes?

2. How many possible ways of finding $q$ DEGs overlapping with $m$ genes in the gene set?

3. How many possible ways of finding the rest $k-q$ DEGs overlapping with ($N-m=n$) genes in the gene set?

## Hypergeometric distribution

$$P_{0}(q|N,m,k) = \sum_{\begin{array}{l}
\textsf{\# possible ways of selecting }q\textsf{ out of }m \\
\textsf{\# possible ways of selecting }(k-q)\textsf{ out of }N-m
\end{array}}
\begin{array}{l}
\textsf{the probability} \\
\textsf{of the gene set}
\end{array}$$

$$=
\overbrace{{m \choose q}}^{
\begin{array}{l}
\textsf{\# ways of choosing } \\
q \textsf{overlap out of }m
\end{array}}
\overbrace{{N-m \choose k - q}}^{
\begin{array}{l}
\textsf{\# ways of choosing } \\
(k-q) \textsf{ out of }N-m
\end{array}}
\underbrace{\frac{1}{{N \choose k}}}_{\textsf{equal probability of the gene set}}
$$


## What is the probability of $k$ overlapping DEGs?

:::::: {.columns}
::: {.column width=.45}


### Hypergenometric PMF

$$p(x|N,m,k) = \frac{{m \choose x} {N - m \choose k-x}}{{N \choose k}}$$

:::
::: {.column width=.45}

### Hypergeometric CDF

$$p(q|N,m,k) = \sum_{x = 0}^{q} \frac{{m \choose x} {N - m \choose k-x}}{{N \choose k}}$$

:::
::::::


## Hypergeometric test for testing significant overlap

$$H_{0}:\, x \le q \quad \textsf{vs.} H_{1}:\, x > q$$

We may observe overlap $q$ genes by random sampling of $k$ genes **without** replacement.

Therefore, we can calculate the p-value:

$$P(x > q|n, m, k) = 1 - \sum_{x = 0}^{q} \frac{{m \choose x } {n \choose k-x}}{{n+m \choose k}}$$

```{r}
phyper(q=6, m=9, n=15, k=8, lower.tail=FALSE)
```

## How significant is $q$ overlap in our discovery?

:::::: {.columns}
::: {.column width=.33}

Fixing $m=9$, $n=15$, and $k=8$,

```{r fig.width=1.8, fig.height=2.7, echo = FALSE, onslide.plot="1-"}
.m <- 9
.n <- 15
.k <- 8
.dt <- data.table(pp = dhyper(0:8, m=.m, n=.n, k=.k),
                  cc = phyper(0:8, m=.m, n=.n, k=.k),
                  x = 0:8,
                  .null = "0_null")

plot.hyper.cutoff <- function(.dt) {
    
    .y.axis <- scale_y_continuous(breaks=c(0, .3, .6, .9))
    .x.axis <- scale_x_continuous(breaks=0:8)

    p1 <- .gg.plot(.dt, aes(x, pp, fill=.null)) +
        geom_bar(stat="identity") +
        .y.axis + .x.axis + xlab("") +
        scale_fill_manual(values=c("gray","red"), guide="none") +
        ylab("probability")

    p2 <- .gg.plot(.dt, aes(x,cc, fill=.null)) +
        geom_bar(stat="identity") +
        .y.axis + .x.axis + xlab("") +
        scale_fill_manual(values=c("gray","red"), guide="none") +
        ylab("cumulative\nprobability")

    .dt.sig <- .dt %>% filter(.null != "0_null")

    p3 <-
        .gg.plot(.dt, aes(x, 1-cc, fill=.null)) +
        geom_line() +
        geom_point(pch=21) +
        scale_y_sqrt(breaks=c(1,.5, 0.05, 1e-2, 0)) + .x.axis +
        scale_fill_manual(values=c("gray","red"), guide="none") +
        ylab("1 - cumulative\nprobability")

    if(nrow(.dt.sig) > 0){
        p3 <- p3 + geom_text(aes(y=.1 + 1 - cc, label = num.sci(1 - cc)),
                             data = .dt.sig,
                             vjust = 0, hjust = 0,
                             size = 2, angle=90)
    }

    wrap_plots(p1,p2,p3,ncol=1, heights=c(1,1,2))
}

plot.hyper.cutoff(.dt)
```

:::
::: {.column width=.33}

If $q=3$:

```{r fig.width=1.8, fig.height=2.7, echo = FALSE, onslide.plot="2-"}
.dt %>% mutate(.null = if_else(x > 3, "1_alt", "0_null")) %>% 
plot.hyper.cutoff()
```

:::
::: {.column width=.33}

If $q=6$:

```{r fig.width=1.8, fig.height=2.7, echo = FALSE, onslide.plot="3-"}
.dt %>% mutate(.null = if_else(x > 6, "1_alt", "0_null")) %>% 
plot.hyper.cutoff()
```

:::
::::::

## Multiple gene sets, multiple hypothesis testing

:::::: {.columns}
::: {.column width=.5}

Which one is significantly overlapping with $k=8$ genes?

```{r results="asis", out.width="\\linewidth", echo=FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_6.pdf")
```

:::
::: {.column width=.5}

Measure the tail probability (p-value):

```{r}
mm <- c(9, 7, 11)        # |gene set|
xx <- c(6, 3, 0)         # |overlap|
N <- 24                  # N. total
pval <- phyper(xx,       # overlap
               m=mm,     # inside
               n=(N-mm), # outside 
               k=8,      # significant
               lower.tail=FALSE)
```

Which one is significant?
```{r fig.width=2, fig.height=1, echo=FALSE, onslide.plot="2-"}
.dt <- data.table(pval) %>% mutate(i=1:n())

.gg.plot(.dt, aes(as.factor(i),-log10(pval))) +
    xlab("gene set") +
    geom_bar(stat="identity", width=.25, fill="gray70") +
    geom_text_repel(aes(label=num.sci(pval)), size = 2, colour="red") +
    scale_y_continuous("p-val", labels=function(x) num.sci(10^(-x)))

```

:::
::::::



## Summary of the gene set analysis by hypergeometric test

:::::: {.columns}
::: {.column width=.5}

**When will it work?**

- A routine to construct a set of differentially expressed genes by
  handling multiple hypothesis testing

- Gene sets are of similar sizes and *nearly* disjoint/independent from one another

- Genes are *nearly* independent (there is no overwhelmingly favourite genes)

:::
::: {.column width=.5}

**When will it fail?**

- **Don't** have a good way to make a set:

  - Our discovery data may lack statistical power, i.e., no (or a few)
    significant genes left after multiple hypothesis correction

- There is a hidden factor that can affect two steps: (1) gene set
  selection (annotations/knowledge) and (2) differential expression
  calling

:::
::::::

## Complete `seminar-07` to better understand GSA

* We will take a look at real-world gene sets--MSigDB pathways and NHGRI-EBI GWAS catalogue.

* We will also discuss [`goseq`](https://bioconductor.org/packages/release/bioc/html/goseq.html) method.

* [Gene ontology analysis for RNA-seq: accounting for selection bias](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-2-r14). 

* We will also demonstrate one kind of gene-level bias induced by gene length.

## Rank-based Gene Set Enrichment Analysis method (Subramanian _et al._ 2005)

### GSEA input

- A collection of gene-sets: $\mathcal{C}_{1}, \ldots, \mathcal{C}_{K}$

- A vector of gene-level scores ($G$ genes): $z_{1}, \ldots, z_{G}$

- Each $z_{g}$ could come from differential expression analysis

### GSEA algorithm

- For each $k$, compute a set-level score $S_{k}(\mathbf{z},\mathcal{C}_{k})$

- E.g., Kolmogorov-Smirnov statistic comparing the distribution $\{z_{g}:\,g \in \mathcal{C}_{k}\}$ vs.  $\{z_{g}:\,g \notin \mathcal{C}_{k}\}$


## Gene Set Enrichment Analysis method (Subramanian _et al._ 2005)

- Construct the null distribution of $S_{1}, \ldots, S_{K}$ by sample label (case-control) or gene-to-set membership permutation

- Using the null distribution by permutation, estimate p-values and false discovery rates

- If we knew the null distribution, we would not need expensive permutations.

:::::: {.columns}
::: {.column width=.45}

**Good**:

- No cutoff/assumptions needed to estimate the null distribution

- Aggregate scores across many genes! (boost the power)

:::
::: {.column width=.45}

**Bad**:

- What is an appropriate statistic?

- What should be permuted? For how long?

:::
::::::


## Let's simulate some gene set data to understand GSEA

### Simulation (Efron and Tibshirani 2007)

1. Generate basal gene expression 

$$X_{i,g} \sim \mathcal{N}\!\left(0,1\right)$$

2. Sample case vs. control membership (the rows of $X$) uniformly at random

3. Sample membership gene to gene set uniformly at random 

4. For the first gene set, select a certain fraction of genes to perturb

5. For the selected genes $g^{*}$, add some $\Delta$ value to $X_{i,g^*}$ if the sample $i$ belongs to the control group


## Let's simulate some gene set data (Efron and Tibshirani 2007)

:::::: {.columns}
::: {.column width=.55}

```{r}
simulate.data <-
    function(G = 1000,        # genes
             K = 150,         # gene sets
             n.samp = 100,    # sample size
             delta = .4,      # perturbation
             p.perturb = 1) { # Pr of petrub
  case.control <- sample(0:1, n.samp, TRUE)
  S <- sample(K, G, TRUE)       # gene sets
  X <- .rnorm(n.samp, G)        # All the other genes
  ## Perturbation of the first gene set
  .genes.1 <- which(S == 1)
  n1 <- length(.genes.1)
  n.perturb <- max(floor(n1 * p.perturb),1)
  .genes.1 <- sample(.genes.1, n.perturb)
  .case <- case.control == 1
  X[.case, .genes.1] <- X[.case, .genes.1] + delta
  require(Matrix)
  .membership <- sparseMatrix(j=1:G, i=S, x=rep(1,G))
  list(X=X, S=.membership, Y=case.control)
}
```

:::
::: {.column width=.35}

```{r}
set.seed(1)
dat <- simulate.data()
```

Let's run t-test for each gene:
```{r}
run.t.test <- function(X, Y){
  .case <- Y == 1
  .ctrl <- Y == 0
  .fun <- function(x){
    t.test(x[.case],
           x[.ctrl])$statistic
  }
  apply(X, 2, .fun)
}
```

:::
::::::


## What will be a proper gene set score?

Gene-level scores across gene sets:

```{r echo=FALSE, fig.width=6, fig.height=2}

zz <-
    data.frame(z = run.t.test(dat$X, dat$Y)) %>%
    mutate(Var2 = 1:n()) %>%
    left_join(reshape2::melt(as.matrix(dat$S), value.name="s"))

.show <- zz %>% filter(Var1 <= 10) %>%
    mutate(s = if_else(s == 0, "outside", "inside"))

.gg.plot(.show, aes(s, `z`, fill = s)) +
    facet_grid(. ~ Var1) +
    geom_violin(scale="width") +
    geom_boxplot(width=.25, fill="white", outlier.stroke=0) +
    xlab("first 10 gene sets") +
    ylab("t-test statistics") +
    theme(axis.text.x = element_blank()) +
    scale_fill_brewer("genes", palette="Paired")
```

## What will be a proper gene set score?

Can we simply aggregate gene-level z-scores (or t-statistics) within each set?

::: {.block}

### Irizarry _et al._ (2009), using Stouffer Z-score

$$S_{k} = \sum_{g \in \mathcal{C}_{k}} z_{g} /  \sqrt{|\mathcal{C}_{k}|} \sim \mathcal{N}\!\left(0, 1\right)$$
if $Z_{g} \sim \mathcal{N}\!\left(0,1\right),\,\forall g$ 
:::

:::::: {.columns}
::: {.column width=.4}

```{r}
geneset.score <- function(X, S, Y) {
    z.genes <- run.t.test(X, Y)
    n.sets <- apply(S, 1, sum)
    z.sets <- (S %*% z.genes /
               sqrt(n.sets))
}
```

:::
::: {.column width=.45}


```{r}
z.sets <- geneset.score(dat$X, dat$S, dat$Y)                        
```

```{r include=FALSE}
.qq.norm <- function(zz, ylab = "z-scores"){
    .qq <- qqnorm(as.numeric(zz), plot.it=FALSE)
    .dt <- setDT(.qq)
    .dt.sig <- .dt[abs(y) > 2 & abs(y) > 1.25*abs(x)]
    .gg.plot(.dt, aes(x,y)) +
        geom_point(stroke=0, size=.7) +
        geom_point(data=.dt.sig, size=2, pch=21, colour="red") +
        geom_abline(slope=1, colour=2) +
        xlab("z ~ N(0,1)") +
        ylab(ylab)
}
```


```{r fig.width=2, fig.height=1.25, echo=FALSE, only.plot="2"}
.qq.norm(z.sets, "set-level\n z-scores")
```

```{r include=FALSE}
.pv.plot <- function(zz) {
    .dt <- data.table(z = as.numeric(zz)) %>%
        mutate(i = 1:n()) %>%
        mutate(pv = 2 * pnorm(abs(z), lower.tail=FALSE)) %>%
        mutate(l10.pv = -log10(pv))
    .dt.sig <- .dt[pv < 1e-2]
    .gg.plot(.dt, aes(as.factor(i),l10.pv)) +
        geom_point(stroke=0, size=.7) +
        geom_point(data=.dt.sig, size=2, pch=21, colour="red") +
        theme(axis.text.x = element_blank()) +
        theme(axis.ticks.x = element_blank()) +
        geom_hline(yintercept = -log10(0.01), colour="red", lty=2) +
        xlab("gene sets") +
        scale_y_continuous("p-val",
                           labels=function(x) num.sci(10^(-x)))
}
```

```{r fig.width=2, fig.height=1.25, echo=FALSE, only.plot="3"}
.pv.plot(z.sets)
```

:::
::::::

## Constructing the null distribution by gene permutation

What if we don't know the distribution of set-wise scores?

:::::: {.columns}
::: {.column width=.6}

```{r}
S.perm <- t(apply(dat$S, 1, sample))
z.perm <- geneset.score(dat$X, S.perm, dat$Y)
```

```{r fig.width=3.5, fig.height=1.25, echo=FALSE}
.qq.norm(z.perm, "permuted\nz-scores") | .pv.plot(z.perm)
```

:::
::: {.column width=.35}

* Repeat the permutation of gene set membership matrix while
  preserving the number of genes within each set

* Compute set-level z-scores (or a similar kind) and construct the null
  distribution

* Calculate p-values by counting the frequency of observed $S_{k}^{*} > S_{k}^{\textsf{perm}}$

:::
::::::

## Constructing the null distribution by sample permutation

:::::: {.columns}
::: {.column width=.65}


```{r}
Y.perm <- sample(dat$Y)
z.perm <- geneset.score(dat$X, S.perm, Y.perm)
```

```{r fig.width=3.5, fig.height=1.25, echo=FALSE}
.qq.norm(z.perm, "permuted\nz-scores") | .pv.plot(z.perm)
```

:::
::: {.column width=.35}

* Repeat the permutation of case-control labels while
  preserving the same number of cases and controls

* Compute set-level z-scores (or a similar kind) and construct the null
  distribution

* Calculate p-values by counting the frequency of observed $S_{k}^{*} > S_{k}^{\textsf{perm}}$

:::
::::::

## Again, complete `seminar-07` to better understand GSEA

* When we have little confidence on the null distribution of gene-set scores, we usually rely on many, many steps of permutations 

* A naive permutation scheme is highly inefficient, so we will use fast GSEA (`fgsea`) and approximate p-value calculation

* Check out this preprint: [https://www.biorxiv.org/content/10.1101/060012v3](https://www.biorxiv.org/content/10.1101/060012v3)

# Biological network analysis

## What is network? Some graph theory terms

* Network is a graph, which is a set of sets

* We define a graph as a tuple $G = (V, E)$ if undirected:

    * V (or $V(G)$): a set of vertices, $V = \{v_{1}, \ldots, v_{n}\}$

    * E (or $E(G)$): a set of edges, $E = \{(v_{i}, v_{j}):\, \textsf{if vertices } i,j \textsf{ are conected}\}$

* $n(G) = |V(G)|$ number of the vertices in $G$, the size of the set $V$ (or simply $n$)

* $m(G) = |E(G)|$ number of the edges (connected pairs) in $G$, the size of the set $E$ (or simply $m$)

* $d_{v}(G)=$ degree of a vertex $v$'s neighbours in $G$ (# how many friends?)

## We can use `igraph` in `R`

```{r size = "large"}
library(igraph)
```

* We can use `igraph` in `R` or `Python` or `C++`.

## Let's take a look at some classic examples

Download some from Mark Newman's website:

\vspace{10pt}

```{r size = "tiny"}
#' @param .src www location
#' @param .dir downloading local directory
#' @param .zip zip file name
#' @param .tgt target gml file name
.read.online <- function(.src,
                         .dir="Data/",
                         .zip = str_c(.dir,basename(.src)),
                         .tgt = str_replace(.zip, "zip$", "gml")){
    if(!file.exists(.tgt)){
        .gml <- basename(.tgt)                     # remove the dir name
        download.file(.src, .zip)                  # download from the web
        unzip(.zip, files=.gml, exdir = .dir)      # unzip
    }
    return(igraph::read_graph(.tgt, format="gml")) # read them into memory
}
```

```{r size = "scriptsize"}
karate <- .read.online("http://www-personal.umich.edu/~mejn/netdata/karate.zip")
polblog <- .read.online("http://www-personal.umich.edu/~mejn/netdata/polblogs.zip")
netsci <- .read.online("http://www-personal.umich.edu/~mejn/netdata/netscience.zip")
football <- .read.online("http://www-personal.umich.edu/~mejn/netdata/football.zip")
condmat <- .read.online("http://www-personal.umich.edu/~mejn/netdata/cond-mat-2005.zip")
```

## Handy functions for visualizing a network

We want to match graph vertices with the layout coordinates found by
`igraph::layout_nicely` and make it easy to show in `ggplot` or something else.

:::::: {.columns}
::: {.column width=.5}

```{r}
#' @param G igraph object
#' @param layout.file local file
find.nice.layout <-
    function(G, layout.file) {

    if(!file.exists(layout.file)){
        layout.dt <-
            layout_nicely(G) %>%
            as.data.table()
        saveRDS(layout.dt, layout.file)
    }
    readRDS(layout.file)
}
```

:::
::: {.column width=.5}

```{r}
#' @param G igraph object
#' @param .name file header
apply.layout.dt <- function(G, .name){
  .out.file <-
    str_c(fig.dir,"/",.name,".rds")

  .out <-
    find.nice.layout(G, .out.file) %>%
    dplyr::mutate(v = 1:dplyr::n()) # index

  as_long_data_frame(G) %>%
    as.data.table %>% 
    merge(.out, by.x= "from", by.y="v") %>%
    merge(.out, by.x= "to", by.y="v",
        suffixes=c(".from",".to"))
}
```

:::
::::::

## Plotting a graph with points and segments in `ggplot`

```{r size = "tiny"}
plot.layout.dt <- function(.dt, .palette="Paired", .palette.e = "Set2", .esize = .5, .vsize = 5, .add.lab=TRUE){
  if(!("k.from" %in% colnames(.dt))) .dt[, k.from := 1]                    # add membership
  if(!("k.to" %in% colnames(.dt))) .dt[, k.to := 1]                        # add membership
  .rename <- function(xx) { colnames(xx) <- c("v","V1","V2","k"); xx }     # Find a consolidated
  .dt.v <-                                                                 # set of vertices
    rbind(.dt[, .(`from`, `V1.from`, `V2.from`, `k.from`)] %>% .rename(),
        .dt[, .(`to`, `V1.to`, `V2.to`, `k.to`)] %>% .rename()) %>%
    dplyr::mutate(k = as.factor(k)) %>% unique
                                              
  .aes.e <- aes(V1.from, V2.from, xend=V1.to, yend=V2.to)   # edge colours
  if("k.edge" %in% colnames(.dt)) {
    .aes.e <- aes(V1.from, V2.from, xend=V1.to, yend=V2.to, colour=as.factor(k.edge))
  }
  plt <- ggplot() + theme_void()                                           # show no axis
  if("k.edge" %in% colnames(.dt)) {
    plt <- plt +
      geom_segment(.aes.e, data = .dt, size = .esize) +                    # draw edges
      scale_colour_brewer(palette=.palette.e, na.value="grey", guide="none")
  } else {
    plt <- plt +
      geom_segment(.aes.e, data = .dt, size = .esize, colour="gray")       # draw edges
  }
  plt <- plt +
    geom_point(aes(V1, V2, fill=k), data = .dt.v, pch=21, stroke=.1, size = .vsize) + # vertices
    scale_fill_brewer(palette = .palette, guide="none")                    # vertex colouring

  if(.add.lab){ plt <- plt + geom_text(aes(V1, V2, label=v), data = .dt.v, size = 3) }
  return(plt)
}
```

## Social network examples 

:::::: {.columns}
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.vv <- V(polblog)[degree(polblog) >= 3]
polblog.sub <- induced_subgraph(polblog, .vv)
apply.layout.dt(polblog.sub, "polblog.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=2, .esize=.2)
```

* L. A. Adamic and N. Glance, "The political blogosphere and the 2004 US Election", in Proceedings of the WWW-2005 Workshop on the Weblogging Ecosystem (2005).

:::
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.comp <- components(netsci)
.vv <- V(netsci)[.comp$membership == which.max(.comp$csize)]
netsci.sub <- induced_subgraph(netsci, .vv)

apply.layout.dt(netsci.sub, "netsci.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=2, .esize=.2)
```

* Coauthorship network of scientists working on network theory and experiment

* Showing only the largest component

* M. Newman in May 2006.

:::
::::::

## More examples

:::::: {.columns}
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=1.6}
.vv <- V(football)[degree(football) >= 3]
football.sub <- induced_subgraph(football, .vv)
apply.layout.dt(football.sub, "football.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=2, .esize=.2)
```

* Network of American football games between Division IA colleges during regular season Fall 2000. 

* M. Girvan and M. E. J. Newman, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002).

:::
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=1.8}
G <- condmat

apply.degree.cutoff <- function(G, .cutoff = 5) {
    .sub <- G
    .rr <- sum(degree(.sub) < .cutoff)
    while(.rr > 0){
        vv <- V(.sub)
        .vv <- vv[degree(.sub) >= .cutoff]
        .sub <- induced_subgraph(.sub, .vv)
        .rr <- sum(degree(.sub) < .cutoff)
    }
    return(.sub)
}

condmat.sub <- apply.degree.cutoff(G)
apply.layout.dt(condmat.sub, "condmat.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=.3)
```

* Co-authorships between scientists posting preprints on the Condensed Matter E-Print Archive. M. Newman, PNAS (2001).

* Showing densely-connected part (iterative degree cutoff >= 5)

:::
::::::

## Biological network: Human Reference Protein-Protein interaction map

:::::: {.columns}
::: {.column width=.5}

* Download the data from `interactome-atlas.org`

```{r}
db.url <- "http://www.interactome-atlas.org"
ppi.net.file <- "Data/HI-union.tsv.gz"
if(!file.exists(ppi.net.file)){
    .file <- str_remove(ppi.net.file, "[.]gz$")
    .url <- str_c(db.url,"/data/HI-union.tsv")
    download.file(.url, destfile = .file)
    R.utils::gzip(.file)
}
```

* Build a network from a list of interacting pairs

```{r}
ppi.pairs <-
  fread(ppi.net.file, header=FALSE, col.names=c("v1","v2")) %>%
  filter(v1 != v2) %>% as.matrix
G.ppi <- graph_from_edgelist(ppi.pairs, directed = FALSE)
```

:::
::: {.column width=.45}

* Vertices: genes (or the resulting proteins)

* Edges: two or multiple genes work together (could have many different meanings)

```{r}
n <- length(V(G.ppi))
m <- length(E(G.ppi))
```

* n = `r n` vertices

* m = `r m` edges

:::
::::::

## Biological network: Human Reference Protein-Protein interaction map

:::::: {.columns}
::: {.column width=.5}

```{r echo=FALSE, fig.width=3, fig.height=3}
apply.layout.dt(G.ppi, "ppi") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::: {.column width=.45}

* Vertices: genes (or the resulting proteins)

* Edges: two or multiple genes work together (could have many different meanings)

```{r}
n <- length(V(G.ppi))
m <- length(E(G.ppi))
```

* n = `r n` vertices

* m = `r m` edges

Sources of biological networks:

* High-throughput experiments

* Co-expression analysis

* Literature-based curation

:::
::::::

## Degree distribution (How many friends?)

::: {.block}

### Vertex degree

For each vertex $v \in V(G)$: $d_{v} = \sum_{u} A_{uv}$

:::

* It is simple to calculate in `igraph`:

```{r}
deg.dt <- degree(G.ppi) %>% 
    (function(.d)
        data.table(d=.d, v = names(.d))
    )
```

* Degree distributions may teach us the underlying generative scheme

* Power-law (almost linear slope in a log-log plot) may indicate a "rich-get-richer" phenomenon.

* The majority with $< 10$ neighbours vs. hub nodes with $> 100$ neighbours

* Poisson distribution if edges are drawn uniformly at random

## Degree distribution (How many friends?)

A handy one-liner:

```{r}
.dt <- deg.dt[, .(count=.N), by=.(d)]
```

Log-log plot:

```{r fig.width=2, fig.height=1.5, echo=FALSE}
.gg.plot(.dt, aes(x=`d`, y=`count`)) +
    geom_point(stroke=0) +
    scale_x_log10() +
    scale_y_log10()
```

## Connected components and a giant component

:::::: {.columns}
::: {.column width=.6}

```{r echo=FALSE, fig.width=3, fig.height=3}
apply.layout.dt(G.ppi, "ppi") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::: {.column width=.4}

A (connected) component = a set of vertices reachable by hopping
through edges.

```{r}
.comp <- components(G.ppi)
```

Found `r .comp$no` connected components

```{r echo = FALSE, results="asis"}
.dt <- data.table(n=.comp$csize);
knitr::kable(.dt[, .(count=.N), by=.(`n`)])
```

* Can we take the giant one?

```{r}
k <- which.max(.comp$csize)
.sub <- names(.comp$membership)[
    .comp$membership==k]
G.ppi.sub <- induced_subgraph(G.ppi, .sub)
```

:::
::::::

## A subgraph induced by genes/proteins in the giant component

:::::: {.columns}
::: {.column width=.64}

```{r echo=FALSE, fig.width=4, fig.height=3}
apply.layout.dt(G.ppi.sub, "ppi-giant") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::: {.column width=.35}

* $n(G)$: `r length(V(G.ppi.sub))` (vs. `r length(V(G.ppi))`)

* $m(G)$: `r length(E(G.ppi.sub))` (vs. `r length(E(G.ppi))`)

* Degree distribution:

```{r echo=FALSE, fig.width=2, fig.height=1.75}
.dt <- data.table(d=degree(G.ppi.sub))
.dt <- .dt[, .(count = .N), by = .(d)]
.gg.plot(.dt, aes(x=d, y=count)) + geom_point(stroke=0) + scale_x_log10() + scale_y_log10()
```

:::
::::::

## Iterative degree cutoff to remove dangling vertices

:::::: {.columns}
::: {.column width=.5}

We may consider this as a Q/C step:

```{r}
degree.cutoff <- function(G, .cutoff = 3) {
    G.sub <- G
    n.remove <- sum(degree(G.sub) < .cutoff)
    while(n.remove > 0){
        vv <- V(G.sub)
        .retain <- vv[degree(G.sub) >= .cutoff]
        G.sub <- induced_subgraph(G.sub, .retain)
        n.remove <- sum(degree(G.sub) < .cutoff)
    }
    return(G.sub)
}
G.dc <- degree.cutoff(G.ppi.sub, 3)
```

Comparison with the raw PPI data:

* $n(G)$: `r length(V(G.dc))` (vs. `r length(V(G.ppi))`)

* $m(G)$: `r length(E(G.dc))` (vs. `r length(E(G.ppi))`)

:::
::: {.column width=.5}

Will it look nicer?

```{r echo=FALSE, fig.width=2, fig.height=1.5}
apply.layout.dt(G.dc, "ppi-dc") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::::::


## Iterative degree cutoff to remove dangling vertices

:::::: {.columns}
::: {.column width=.5}

Degree distribution:

```{r echo=FALSE, fig.width=2, fig.height=1.75}
.dt <- data.table(d=degree(G.dc))
.dt <- .dt[, .(count = .N), by = .(d)]
.gg.plot(.dt, aes(x=d, y=count)) + geom_point(stroke=0) + scale_x_log10() + scale_y_log10()
```

* $n(G)$: `r length(V(G.dc))` (vs. `r length(V(G.ppi))`)

* $m(G)$: `r length(E(G.dc))` (vs. `r length(E(G.ppi))`)

* Note: $d$ starts from `3`

:::
::: {.column width=.5}

Will it look nicer?

```{r echo=FALSE, fig.width=2, fig.height=1.5}
apply.layout.dt(G.dc, "ppi-dc") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

* Rationale: no genes act alone. If some genes have significantly fewer edges connected, high-throughput experiments had not covered them sufficiently.

:::
::::::

<!------------->
<!-- Network -->
<!------------->

## Let's use this PPI network to understand disease mechanisms

We can download public data mapping SNPs (genes) to diseases/phenotypes from [the NHGRI-EBI GWAS Catalog](https://www.ebi.ac.uk/gwas/)

* GWAS: genome-wide association study (will cover later)

* Again, `seminar-07` also covers GWAS catalogue.

```{r echo = FALSE}
.url <- "https://www.ebi.ac.uk/gwas/api/search/downloads/alternative"
.gwas.catalog.file <- "Data/gwas_catalog_v1.0.2-associations_e105_r2021-12-21.tsv.gz"
if(!file.exists(.gwas.catalog.file)){
    .file <- stringr::str_remove(.gwas.catalog.file, ".gz$")
    download.file(.url, destfile = .file)
    R.utils::gzip(.file)
}
```

Let's retrieve a list of Multiple Sclerosis (MS)-related genes

```{r size="tiny"}
.gwas.dt <- fread(.gwas.catalog.file, sep="\t", quote="")
is.ms.trait <- function(x) str_detect(x, "[Mm]ultiple sclerosis")
ms.genes <-
 .gwas.dt[is.ms.trait(`DISEASE/TRAIT`),] %>%
 filter(str_length(`MAPPED_GENE`) > 2) %>% 
 select(`MAPPED_GENE`) %>% na.omit %>% unlist %>%
 str_split(pattern="[ ,;]+" ) %>% unlist %>% unique 
```

## Gene prioritization: a toy example of multiple sclerosis GWAS

```{r echo = FALSE}
read.ensembl.info <- function(ensg, .file = str_c(fig.dir, "/ensembl.RDS")) {
    
    if(file.exists(.file)) { return(readRDS(.file)) }

    .mart <- biomaRt::useMart(biomart='ENSEMBL_MART_ENSEMBL',
                                host='uswest.ensembl.org',
                                path='/biomart/martservice',
                                dataset='hsapiens_gene_ensembl')
    
    ensembl.hs = biomaRt::useDataset('hsapiens_gene_ensembl', .mart)

    .attr <- c('ensembl_gene_id', 'hgnc_symbol', 'go_id',
               'name_1006', 'namespace_1003')

    .dt <- biomaRt::getBM(attributes=.attr,
                          filters='ensembl_gene_id', values=ensg,
                          mart=ensembl.hs, useCache = FALSE)

    saveRDS(unique(as.data.table(.dt)), .file)
    return(.dt)
}
gene.info <- read.ensembl.info(names(V(G.ppi)))
```

How many of them overlap with the vertices in the PPI network?

```{r}
vtot <- V(G.ppi)
v.dt <- data.table(v=vtot,ensembl_gene_id=names(vtot))
.dt <- merge(v.dt, gene.info)
overlap.dt <-
  .dt[hgnc_symbol %in% ms.genes,
      .(v, ensembl_gene_id, hgnc_symbol)
     ] %>% unique
```

* `r nrow(overlap.dt)` genes (of `r length(ms.genes)` MS genes)
  recapitulated in the network

* That is a small fraction compared to the total `r length(V(G.ppi))`
  genes in the network

* What if no mutations occurred in other relevant genes? No mutation
  $\to$ no association.

## Mapping disease genes onto a gene-gene interaction network

:::::: {.columns}
::: {.column width=.5}

Revisiting the gene-gene (protein-protein) interaction network

\vspace{12pt}

```{r echo = FALSE, fig.width=2, fig.height=1.75, onslide.plot="1-"}
.dt <- apply.layout.dt(G.ppi, "ppi")
.dt[, k.from := "2_WT"]; .dt[, k.to := "2_WT"]
.dt[`to` %in% overlap.dt$v, k.to := "1_MS"]
.dt[`from` %in% overlap.dt$v, k.from := "1_MS"]

plot.layout.dt(.dt, .palette = "RdBu", .add.lab=FALSE, .vsize=1, .esize=.05)
```

* Where are my GWAS genes in the network? 

:::
::: {.column width=.5}

```{r echo = FALSE}
.dt <- apply.layout.dt(G.ppi, "ppi")

.x.scale <- 
    scale_x_continuous(limits = c(min(.dt$V1.from), max(.dt$V1.to)))

.y.scale <- 
    scale_y_continuous(limits = c(min(.dt$V2.from), max(.dt$V2.to)))
```

```{r echo = FALSE, fig.width=2, fig.height=1.75, only.plot="2"}
vset <- overlap.dt$v

.dt.sub <- .dt[`to` %in% vset & `from` %in% vset, ]

plt <- plot.layout.dt(.dt.sub, .palette = "RdBu",
                      .add.lab=FALSE, .vsize=2, .esize=.5)

.title <- str_c(nrow(overlap.dt), " MS GWAS genes\n(",
                round(100 * length(vset) / length(V(G.ppi))), "%)")

plt.ms.gwas <- plt + .x.scale + .y.scale + ggtitle(.title) + theme(title=element_text(size=8))
print(plt.ms.gwas)
```

```{r echo = FALSE}
.neigh <- function(vv, nn){
    lapply(vv, function(v) neighbors(G.ppi, v, mode="all")) %>% 
    do.call(what = c) %>% unique
}
```

```{r echo = FALSE, fig.width=2, fig.height=1.75, only.plot="3"}
v.neigh <- .neigh(overlap.dt$v)

vset <- union(v.neigh, overlap.dt$v)

.dt.sub <- .dt[`to` %in% vset &
                `from` %in% vset, ]

plt <- plot.layout.dt(.dt.sub, .palette = "RdBu",
                      .add.lab=FALSE, .vsize=1, .esize=.5)

.title <- str_c(length(vset), ", MS genes+\nimmediate neighbours\n(",
                round(100 * length(vset) / length(V(G.ppi))), "%)")

plt + .x.scale + .y.scale + ggtitle(.title) + theme(title=element_text(size=8))
```


```{r echo = FALSE, fig.width=2, fig.height=1.75, only.plot="4"}
v.neigh <- .neigh(vset)

vset <- union(v.neigh, vset)

.dt.sub <- .dt[`to` %in% vset &
                `from` %in% vset, ]

plt <- plot.layout.dt(.dt.sub, .palette = "RdBu",
                      .add.lab=FALSE, .vsize=1, .esize=.5)

.title <- str_c(length(vset), " MS genes\nneighbours in two hops\n(",
                round(100 * length(vset) / length(V(G.ppi))), "%)")

plt + .x.scale + .y.scale + ggtitle(.title) + theme(title=element_text(size=8))
```

* Genes immediately hit by GWAS are probably *not* comprehensive enough.

* It seems like that we can extend the set by propagating across the edges

:::
::::::

## Can we prioritize disease-relevant genes using PPI network?

* GWAS might cover too few candidate genes...

* Naively expanding the set by all the neighbourhood would be too many...

* Not all the neighbours are affected by the disease... 

* Who are the relevant neighbours?

* **Network $\approx$ Information flow diagram**

* Spreading "labels" in the information network

## Random walk probability: What are the probabilities of visiting neighbours?

:::::: {.columns}
::: {.column width=.5}

A wrapper function for `igraph`'s `random_walk()`

```{r}
.rand.walk <- function(vv, nn){
  .fun <-
    function(v) 
      random_walk(G.ppi, v, nn, mode="all")
  lapply(vv, .fun) %>%
      do.call(what = c) %>%
      unique
}
```

Let's take five steps from the MS genes:

```{r}
v0 <- overlap.dt$v # seed
v.1 <- .rand.walk(v0,1)
v.2 <- .rand.walk(v0,2)
v.3 <- .rand.walk(v0,3)
```

```{r echo = FALSE}
n.1 <- v0
nn <- .neigh(v0)
n.2 <- nn
nn <- .neigh(nn)
n.3 <- nn
```

:::
::: {.column width=.5}

Some vertices are more frequently visited when we randomly traverse in the network.


```{r echo=FALSE, fig.width=2, fig.height=1.75, only.plot=1}
.build.dt.sub <- function(.dt, vv, nn) {
    .vset <- c(vv, nn)
    .dt.sub <- .dt[`to` %in% .vset & `from` %in% .vset]
    .dt.sub[`to` %in% vv, k.to := "r"]
    .dt.sub[`from` %in% vv, k.from := "r"]
    .dt.sub[`to` %in% vv & `from` %in% vv, k.edge := "r"]
    rbind(.dt.sub[is.na(k.edge), ],
          .dt.sub[!is.na(k.edge), ])
}
.dt <- apply.layout.dt(G.ppi, "ppi")
.dt.sub <- .build.dt.sub(.dt, v.1, n.1)
plot.layout.dt(.dt.sub, .palette="RdBu", 
               .add.lab = FALSE, .vsize=1, .esize=.5) +
    ggtitle(str_c("n=", length(v.1), " / ", length(n.1))) +
    theme(title=element_text(size=8)) +
    .x.scale + .y.scale
```

```{r echo=FALSE, fig.width=2, fig.height=1.75, only.plot=2}
.dt.sub <- .build.dt.sub(.dt, v.2, n.2)
plot.layout.dt(.dt.sub, .palette="RdBu", 
               .add.lab = FALSE, .vsize=1, .esize=.5) +
    ggtitle(str_c("n=", length(v.2), " / ", length(n.2))) +
    theme(title=element_text(size=8)) +
    .x.scale + .y.scale
```

```{r echo=FALSE, fig.width=2, fig.height=1.75, only.plot=3}
.dt.sub <- .build.dt.sub(.dt, v.3, n.3)
plot.layout.dt(.dt.sub, .palette="RdBu", 
               .add.lab = FALSE, .vsize=1, .esize=.5) +
    ggtitle(str_c("n=", length(v.3), " / ", length(n.3))) +
    theme(title=element_text(size=8)) +
    .x.scale + .y.scale
```

:::
::::::

## What are the probabilities of visits from the disease genes?

* We can represent the network as an adjacency matrix $A$, where $A_{ij}=1$ if vertices $i$ and $j$ are connected.

* Define a weight matrix $W_{ij} = Pr(j \to i)$ with equal probabilities, i.e., $W_{ij} \gets A_{ij} / \sum_{i} A_{ij}$.

$$\mathbf{p}^{(t)} \gets \gamma W \mathbf{p}^{(t-1)} + (1- \gamma) \mathbf{p}^{(0)}$$

* We initialize $\mathbf{p}^{(0)}$ by the disease genes, setting $p_{i} = 1/\#$ disease genes if a gene $i$ is in the MS GWAS.


## What are the probabilities of visits from the disease genes?

The code is actually simpler than explanation:

:::::: {.columns}
::: {.column width=.45}

Initialization:

```{r}
A <- as_adjacency_matrix(G.ppi)
d <- degree(G.ppi)
W <- sweep(A, 2, d, `/`)

.v <- as.integer(overlap.dt$v)
n <- length(V(G.ppi))
pr <- matrix(0, n, 1)
pr[.v, 1] <- 1
pr.0 <- pr / sum(pr)
```

:::
::: {.column width=.45}

Take `100` random walks:

```{r}
pr <- pr.0; r <- 0.85
P <- matrix(NA, n, 100)
P[,  1] <-  as.numeric(pr)
for(tt in 1:99) {
    pr <- r * W %*% pr + (1 - r) * pr.0
    pr <- pr / sum(pr)
    P[, tt + 1] <-  as.numeric(pr)
}
```

:::
::::::

## What are the probabilities of visits from the disease genes?


```{r echo = FALSE, fig.width=6, fig.height=1, onslide.plot="1-"}
.dt <- data.table(v=as.integer(V(G.ppi)), pr=as.numeric(pr.0))
.gg.plot(.dt, aes(v,pr)) + geom_line() + ylab("p(0)") + xlab("vertices")
```

```{r echo = FALSE, fig.width=6, fig.height=1.5, onslide.plot="2"}
.dt <- data.table(v=as.integer(V(G.ppi)), pr=as.numeric(P[, 100]))
.gg.plot(.dt, aes(v,pr)) + geom_line() + ylab("p(100)") + xlab("vertices")
```

## Top 50 genes identified by random walk from MS GWAS

```{r echo = FALSE, fig.width=3, fig.height=3}
vtot <- V(G.ppi)
v1 <- vtot[order(P[,100], decreasing=TRUE)[1:50]]
G.sub <- induced_subgraph(G.ppi, v1)
.dt <- apply.layout.dt(G.sub, "ppi_ms")

plot.layout.dt(.dt, .add.lab=FALSE, .vsize=2, .esize=.5)
```

## Are simply we recapitulating high-degree vertices?

```{r echo=FALSE, fig.width=3, fig.height=2.5}
.dt <- data.table(v=as.integer(V(G.ppi)),
                  d=degree(G.ppi),
                  pr=as.numeric(P[, 100]))

.dt.top <- .dt %>% arrange(desc(pr)) %>% head(100)

.gg.plot(.dt, aes(d,pr)) +
    geom_hex(aes(fill = stat(log10(count)))) +
    geom_point(data = .dt.top, colour="red", pch=21) +
    geom_smooth(method="lm", se=FALSE, size=.5, colour="black", lty=2) +
    scale_fill_distiller("count", direction = 1, labels=function(x) round(10^x)) +
    theme(legend.key.width=unit(.2, "lines")) +
    theme(legend.key.height=unit(.5, "lines")) +
    scale_x_log10() +
    scale_y_log10() +
    ylab("p(100)") +
    xlab("degree")
```

Red dots: top 100 genes.

<!---------------------------->
<!-- stochastic block model -->
<!---------------------------->

# Learning structures in biological networks

## Some useful packages in `R`

We can use `igraph` in `R` or `Python` or `C++`.

```{r}
library(igraph)
```

This is my own R/C++ package that can find a stochastic block model in an adjacency matrix.

```{r eval=FALSE}
remotes::install_github("YPARK/hsblock")
```

```{r}
library(hsblock)
```

## Community detection in Zachary's karate club (motivating example)

:::::: {.columns}
::: {.column width=.45}

* Social network of friendships between 34 members of a karate club at a US university in the 1970s.

* W. W. Zachary, An information flow model for conflict and fission in small groups, Journal of Anthropological Research 33, 452-473 (1977).

```{r echo = FALSE}
karate <- .read.online("http://www-personal.umich.edu/~mejn/netdata/karate.zip")
```

* **Vertex**: a member in the karate club; **edge**: friendship

* How many samples?

* What is the dimensionality?

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.karate.dt <- apply.layout.dt(karate, "karate")
plot.layout.dt(.karate.dt)
```

:::
::::::

## A graph-theoretic approach: Community detection by discrete optimization

:::::: {.columns}
::: {.column width=.45}

* Consider two groups

* Find a set of edges to induce two disconnected components

* Not so ideal for a sparse, irregular graph

:::
::: {.column width=.45}

A trivial solution (min cut = 1)

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.dt <- apply.layout.dt(karate, "karate")
.dt[, k.to := 1]
.dt[, k.from := 1]
.dt[`from` == 12, k.from := 2]
.dt[`to` == 12, k.to := 2]

plot.layout.dt(.dt)
```

:::
::::::


## Who are the "influencers" in the karate club?

:::::: {.columns}
::: {.column width=.45}

* Network is not just a mathematical object

* Vertices and edges have a meaning

* Member __1__: the instructor ("Mr. Hi"), probably the founder?

* Member __34__: the president (John A)

* Member __33__: perhaps working with the present (similar interaction patterns)

:::
::: {.column width=.45}

A trivial solution (min cut = 1)

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.dt <- apply.layout.dt(karate, "karate")
.dt[, k.to := 1]
.dt[, k.from := 1]
.dt[`from` == 12, k.from := 2]
.dt[`to` == 12, k.to := 2]
.dt[`from` %in% 1, k.from := 3]
.dt[`to` %in% 1, k.to := 3]
.dt[`from` %in% c(33, 34), k.from := 4]
.dt[`to` %in% c(33, 34), k.to := 4]

plot.layout.dt(.dt)
```

:::
::::::


## Finding min-cuts from the source to target vertices

:::::: {.columns}
::: {.column width=.45}

```{r}
.cuts <- as.directed(karate) %>% 
    st_min_cuts(source = "1", target = c("33","34"))
.sets <- .cuts[["partition1s"]] %>%
    lapply(as.character)
```

* Multiple solutions with the same min-cut=`r .cuts$value/2` edges.

* A partition from "1":

```{r results="asis"}
str_c(sort(.cuts$partition1s[[1]]), collapse=", ")
```

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.dt <- apply.layout.dt(karate, "karate") %>%
    mutate(k.from = 0, k.to = 0)

.dt[`from` %in% .sets[[1]], k.from := 2]
.dt[`to` %in% .sets[[1]], k.to := 2]
plot.layout.dt(.dt)
```

:::
::::::


## Finding min-cuts from the source to target vertices -- 2

:::::: {.columns}
::: {.column width=.45}

* Multiple solutions with the same min-cut=`r .cuts$value/2` edges.

* A partition from "1":

```{r results="asis"}
str_c(sort(.cuts$partition1s[[2]]), collapse=", ")
```

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.v2 <- setdiff(.sets[[2]], .sets[[1]])
.dt[`from` %in% .v2, k.from := 3]
.dt[`to` %in% .v2, k.to := 3]
plot.layout.dt(.dt)
```

:::
::::::


## Finding min-cuts from the source to target vertices -- 3

:::::: {.columns}
::: {.column width=.45}

* Multiple solutions with the same min-cut=`r .cuts$value/2` edges.

* A partition from "1":

```{r results="asis"}
str_c(sort(.cuts$partition1s[[3]]), collapse=", ")
```

* Can we identify group/block structures without the vertex labels (e.g., source and target)?

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=1.75}
.v3 <- setdiff(setdiff(.sets[[3]], .sets[[2]]), .sets[[1]])
.dt[`from` %in% .v3, k.from := 4]
.dt[`to` %in% .v3, k.to := 4]
plot.layout.dt(.dt)
```

:::
::::::

## A generative modelling approach: Stochastic block model (network is an adjacency matrix)

:::::: {.columns}
::: {.column width=.45}

(vertex x vertex)

```{r fig.width=2, fig.height=1.75}
A <- as_adjacency_matrix(karate)
.matshow(A, .scale=FALSE, .lab = 0)
```

:::
::: {.column width=.45}

* **Row/column**: a member in the karate club

* **non-zero element**: friendship between the row and column

* How many samples? What is the dimensionality?

* Can you see group structures?

* Most of $A_{ij} = 0$. Otherwise, there is no reason to consider this matrix as a network.

:::
::::::

## Stochastic block model: membership $Z$ and parameter $\Theta$ 


```{r}
.out <- fit.hsblock(A, "bernoulli", vbiter=100, inner.iter=10, verbose=FALSE)
Z <- as.matrix(.out$Z)          # Cluster x vertex
n <- ncol(Z)                    # Number of vertices
Edges <- 0.5 * Z %*% A %*% t(Z) # Num of edges within/between clusters
.ones <- matrix(1,n,n)          # Total num of pairs
diag(.ones) <- 0                # without cycles
Tot <- Z %*% .ones %*% t(Z)/2   # 
Pr <- Edges / Tot               # Probability of edges within/between clusters
```

* Latent var.: $Z_{ki} = 1$ iff a vertex $i$ $\to$ a cluster $k$

* Model parameters: $\theta_{kk'} \in (0,1)$: pr of edges between $k$ and $k'$

## Stochastic block model: membership $Z$ and parameter $\Theta$ 

```{r echo=FALSE, fig.width=3.8, fig.height=1.8, only.plot="1"}
.p.eq <- ggplot() + theme_void() + geom_text(aes(x=1,y=1,label="~"), size=10)
.p.data <- .matshow(A, .scale=FALSE, .lab = 0) + ggtitle("A")
.p.z <- .matshow(Z, .scale=FALSE, .lab = 0) + ggtitle("Z")
.p.zt <- .matshow(t(Z), .scale=FALSE, .lab = 0) + ggtitle("Z'")
.p.pr <- .matshow(Pr, .scale=TRUE, .lab = 0) + ggtitle("Θ")
.p0 <- ggplot() + theme_void()

wrap_plots(.p.data, .p0, .p.eq, .p0, .p.zt, .p0,
           wrap_plots(.p.pr, .p0, ncol=1, heights=c(1,9)),
           .p0,
           wrap_plots(.p.z, .p0, ncol=1, heights=c(1,9)),
           nrow = 1,
           widths=c(4, .01,.5,.05, .5, .05, .5, .05, 4))
```

```{r echo=FALSE, fig.width=3.8, fig.height=1.8, only.plot="2"}
oo <- order(apply(Z,2,which.max), decreasing=TRUE)

.p.eq <- ggplot() + theme_void() + geom_text(aes(x=1,y=1,label="~"), size=10)
.p.data <- .matshow(A[oo,oo], .scale=FALSE, .lab = 0) + ggtitle("A")
.p.z <- .matshow(Z[,oo], .scale=FALSE, .lab = 0) + ggtitle("Z")
.p.zt <- .matshow(t(Z[,oo]), .scale=FALSE, .lab = 0) + ggtitle("Z'")
.p.pr <- .matshow(Pr, .scale=TRUE, .lab = 0) + ggtitle("Θ")
.p0 <- ggplot() + theme_void()

wrap_plots(.p.data, .p0, .p.eq, .p0, .p.zt, .p0,
           wrap_plots(.p.pr, .p0, ncol=1, heights=c(1,9)),
           .p0,
           wrap_plots(.p.z, .p0, ncol=1, heights=c(1,9)),
           nrow = 1,
           widths=c(4, .01,.5,.05, .5, .05, .5, .05, 4))
```

## A shared neighbourhood matrix (A friend of a friend $\approx$ a friend)

:::::: {.columns}
::: {.column width=.45}

* $S \gets A^{\top} A$

* $S_{ij} = \sum_{k} A_{ki} A_{kj}$, number of shared neighbours

* How many samples? Dimensionality?

* Can you see group structures?

:::
::: {.column width=.45}

```{r fig.width=2, fig.height=1.75}
.matshow(A %*% A, .scale=TRUE, .lab = 0)
```

Brighter red = more frequently sharing neighbours

:::
::::::


## Network is an (edge) incidence matrix (vertex x edge)

::: {.block}

### Incidence matrix

$M_{k,(i,j)} = 1$ if $A_{ik}=1$ and $A_{jk}=1$

:::

```{r}
library(Matrix)
G <- karate;
.list <- ends(G, E(G));
m <- nrow(.list)
ii <- c(.list[,1],.list[,2])
jj <- rep(1:m,2)
xx <- rep(1,2*m)
M <- sparseMatrix(ii, jj, x=xx)
```

## Network is an (edge) incidence matrix (vertex x edge)

$M_{k,(i,j)} = 1$ if $A_{ik}=1$ and $A_{jk}=1$

```{r echo=FALSE, fig.width=3.2, fig.height=1.5}
.matshow(M, .scale=FALSE, .lab = 0)
```

* How many non-zero elements for each column?

* How many samples? Dimensionality? Can you see group structures?

## Enumerating shared neighbours for each edge

::: {.block}

### Shared neighbour incidence matrix

$M_{k,(i,j)} = A_{ki} A_{kj}$

:::

```{r}
ee <- ends(G, E(G));
ii <- ee[,1]
jj <- ee[,2]
M2 <- A[,ii] * A[,jj]
```

## Enumerating shared neighbours for each edge

$M_{k,(i,j)} = A_{ki} A_{kj}$

```{r echo=FALSE, fig.width=3.2, fig.height=1.5}
.matshow(M2, .scale=FALSE, .lab = 0)
```

* How many samples? Dimensionality? Can you see group structures?

## Another way to define the edge incidence matrix

::: {.block}

### Feature loading matrix

$M_{k,(i,j)} = A_{ki} + A_{kj}$

:::

```{r}
ee <- ends(G, E(G));
ii <- ee[,1]
jj <- ee[,2]
M3 <- A[,ii] + A[,jj]
```

We can simply apply an out-of-the-shelf clustering method to this matrix

```{r}
.feat <- t(as.matrix(M3))
.out <- kmeans(.feat, centers=5, nstart=100)               
```

## Another way to define the edge incidence matrix

:::::: {.columns}
::: {.column width=.2}

$M_{k,(i,j)} = A_{ki} + A_{kj}$

:::
::: {.column width=.75}

```{r echo=FALSE, fig.width=4, fig.height=1.75, onslide.plot="1-"}
.matshow(M3, .scale=FALSE, .lab = 0) +
    ggtitle(str_c(nrow(M3), " x ", ncol(M3))) +
    theme(title = element_text(size=8))
```

:::
::::::

:::::: {.columns}
::: {.column width=.2}

_k_-means clustering can recover groups of edges

:::
::: {.column width=.75}

```{r echo=FALSE, fig.width=4, fig.height=.55, onslide.plot="2"}
## .pr <- .matshow(t(.out$centers), .lab=0, .scale=TRUE)
.pz <- .matshow(Matrix::sparseMatrix(i=.out$cluster,j=1:ncol(M3),x=rep(1,ncol(M3))), .scale=FALSE, .lab=0) + ggtitle(str_c(length(unique(.out$cluster)), " clusters x ", length(.out$cluster)," edges")) + theme(title = element_text(size=8))
print(.pz)
##wrap_plots(.pr, wrap_plots(.pz, ggplot() + theme_void(), heights=c(1,9)),
##widths=c(.5,9.5)) 
```

:::
::::::

## We may find overlapping membership by clustering the edges 

:::::: {.columns}
::: {.column width=.35}

$M_{k,(i,j)} = A_{ki} + A_{kj}$

```{r echo = FALSE}
.dt <- apply.layout.dt(karate, "karate")
.dt[, k.edge := as.factor(.out$cluster)]
```

```{r echo = FALSE, fig.width=2, fig.height=1.75}
plot.layout.dt(.dt, .vsize=2, .esize=1, .add.lab=FALSE)
```

:::
::: {.column width=.65}

Sorted edges by the group membership:

```{r echo=FALSE, fig.width=3.2, fig.height=1.5}
.oo <- order(.out$cluster)
.matshow(M3[, .oo], .scale=FALSE, .lab = 0) +
    ggtitle(str_c(nrow(M3), " x ", ncol(M3)))
```

_k_-means clustering can recover groups of edges

```{r echo=FALSE, fig.width=3.2, fig.height=.5}
.pz <- .matshow(Matrix::sparseMatrix(i=.out$cluster[.oo],j=1:ncol(M3),x=rep(1,ncol(M3))), .scale=FALSE, .lab=0) + ggtitle(str_c(length(unique(.out$cluster)), " clusters x ", length(.out$cluster)," edges"))
print(.pz)
```

:::
::::::

## A real-world example: Reactome functional interaction network

```{r echo = FALSE}
.file <- "Data/ractome_edges.txt.gz"
if(!file.exists(.file)){
    .url <- "https://reactome.org/download/tools/ReatomeFIs/FIsInGene_122220_with_annotations.txt"
    .txt.file <- str_remove(.file, ".gz$")
    download.file(.url, destfile = .txt.file)
    R.utils::gzip(.txt.file)
}

.pairs <-
    fread(.file) %>% 
    filter(str_detect(Annotation, "reaction")) %>% 
    filter(Score > .9) %>% 
    select(Gene1, Gene2) %>%
    as.matrix

G <- graph_from_edgelist(.pairs, directed = FALSE)
G.dc <- degree.cutoff(G, 3)
```

```{r echo = FALSE, fig.width=4, fig.height=2.5}
.dt <- apply.layout.dt(G.dc, "reaction")
plot.layout.dt(.dt, .vsize=2, .esize=.5, .add.lab=FALSE)
```

We only took edges with "reaction" for simplicity.

## We can do the same edge clustering

```{r echo = FALSE}
ee <- ends(G.dc, E(G.dc));
ii <- ee[,1]
jj <- ee[,2]
A <- as_adjacency_matrix(G.dc)
M <- A[,ii] + A[,jj]
colnames(M) <- str_c(ii, "-", jj)
rownames(M) <- names(V(G.dc))

.file <- str_c(fig.dir, "/reaction_cluster.RDS")
if(!file.exists(.file)){
    .feat <- t(as.matrix(M))
    .out <- kmeans(.feat, centers=12, nstart=100)
    saveRDS(.out, file=.file)
}
.out <- readRDS(.file)
```

```{r fig.width=6, fig.height=2.5, echo = FALSE}
## Randomly select 15 edges per cluster
.kk <- data.table(e = names(.out$cluster), k = .out$cluster)
.show <- .kk[, head(.SD, 15), by = .(k)]

.vertices <- 
    reshape2::melt(.out$centers) %>%
    filter(value > 0) %>% 
    group_by(Var1) %>%
    top_n(5, `value`) %>% 
    top_n(5, `Var2`) %>% 
    ungroup() %>%
    mutate(r = match(as.character(Var2), names(V(G.dc)))) %>% 
    select(r) %>% 
    unique() %>%
    unlist

m.sorted <- .sort.matrix(as.matrix(M[.vertices, .show$e]))
.matshow(m.sorted, .scale=FALSE, .size=0, .lab = 0) +
    ggtitle("top genes x edges (15 per cluster)")
```

## A new type of gene sets that visualization could not find

```{r echo = FALSE, fig.width=4, fig.height=2.5}
.dt <- apply.layout.dt(G.dc, "reaction")
.dt[, k.edge := as.factor(.out$cluster)]
plot.layout.dt(.dt, .vsize=2, .esize=.5, 
               .palette = "Set3",
               .add.lab=FALSE)
```

## A new type of gene sets that visualization could not find

```{r echo = FALSE, fig.width=6, fig.height=2.5}
.df <- reshape2::melt(.out$centers[, .vertices]) %>%
    mutate(row = Var1, col = Var2, weight = value) %>%
    order.pair(ret.tab=TRUE)

.gg.plot(.df, aes(col, row, fill=weight)) +
    geom_tile(colour="white") +
    ylab("clusters") +
    xlab("top genes") +
    theme(axis.text.x=element_text(angle=90, vjust=0, hjust=0)) +
    scale_x_discrete(position = "top") +
    scale_fill_distiller(palette="RdPu",direction=1)
```


## Summary 

* Gene set analysis (ignoring edges, only vertices)

    - `Similar-07` is your friend

* Diffusion-based network analysis (propagating info via edges)

* Stochastic block model to find sets in a network
