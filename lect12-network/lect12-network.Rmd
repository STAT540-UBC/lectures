---
title: "Systems Biology: Network analysis and Gene set enrichment "
author: "Yongjin Park"
date: "`r format(Sys.time(), '%d %B, %Y')`"
classoption: "aspectratio=169"
fontsize: 10pt
output:
    powerpoint_presentation:
        reference_doc: "_template.pptx"
    html_document:
        self_contained: true
    beamer_presentation:
        keep_tex: true
        latex_engine: xelatex
header-includes:
  - \usetheme[numbering=none]{metropolis}
  - \AtBeginSection[]{\begin{frame}\frametitle{What you will learn}\tableofcontents[currentsection]\end{frame}}
  - \setbeamercolor{background canvas}{bg=white}
  - \definecolor{beaublue}{rgb}{0.74, 0.83, 0.9}
  - \setbeamertemplate{frame footer}{\tiny{\textcolor{beaublue}{Systems Biology}}}
  - | 
    \makeatletter
    \def\ps@titlepage{%
      \setbeamertemplate{footline}{}
    }
    \addtobeamertemplate{title page}{\thispagestyle{titlepage}}{}
    \makeatother
    \include{toc}
---

```{r setup, include=FALSE}
library(tidyverse)
library(data.table)
library(patchwork)
source("Util.R")
source("Setup.R")
fig.dir <- "Fig/network/"
setup.env(fig.dir)
dir.create("Data", showWarnings=FALSE)
```

# What's next after differential expression analysis?

##

* Differential expression analysis of ~20k genes identified tens or
  hundreds of significant genes

* Systems biology will put them together using gene sets (pathways)
  and networks (gene-gene interactions) and find converging stories.

## Let's zoom out: a biological system $\approx$ gene-gene interaction networks

```{r results="asis", out.width=".7\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_1.pdf")
```

\hfill $\to$ **coloured:** some pathway of interest

## Pathways define subsets (partitions) of genes

```{r results="asis", out.width=".7\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_2.pdf")
```

## After controlling FDR, we identified $k$ genes in our case-control analysis

```{r results="asis", out.width=".7\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_3.pdf")
```

## Interestingly, we found $x$ genes are overlapping with this pathway

```{r results="asis", out.width=".7\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_4.pdf")
```

# Set-based, discrete enrichment analysis

## Toy example

:::::: {.columns}
::: {.column width=.5}

```{r results="asis", out.width=".9\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_5.pdf")
```

* $N$: \# genes in this universe

* $m$: \# genes in this get set

* $n$: \# genes *not* in this gene set

* $k$: \# genes found differential expression analysis

:::
::: {.column width=.5}

For each pathway:

* Let's consider this pathway consists of $m=$ 9 genes 

* We found $k=$ 8 DEGs in our RNA-seq analysis 

* Of them, $x=$ 6 genes found overlapping with this pathway

Questions:

* Is it meaningful enough to report?

* Is it surprising enough that we recapitulated 6/9 (~`r round(6/9*100)` %)?

* What is the null distribution?

* What is the generative/simulation scheme?

:::
::::::

## Let's break down the generative process

:::::: {.columns}
::: {.column width=.5}

```{r results="asis", out.width=".9\\linewidth", echo = FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_5.pdf")
```

* $N$: \# genes in this universe

* $m$: \# genes in this get set

* $n$: \# genes *not* in this gene set

* $k$: \# genes found differential expression analysis

:::
::: {.column width=.49}

**Step 1 (existing knowledge)**:

* $m$: the set size of a particular gene set

* $n$: $N$ - \# genes in the set

**Step 2 (new discovery)**:

* $k$: How many genes found in your analysis?

* $x$: How many of the $k$ genes also belong to the gene set of interest?

**Null distribution**:

1. If we sampled some $k$ genes ($0 \le k \le N$) uniformly at random,
   without replacement, from total $N$ genes,

2. How many $x$ of the $k$ genes would overlap with the gene set of
   interest, containing $m$ genes?

:::
::::::


## Let's count the numbers to figure out hypergeometric distribution 

:::::: {.columns}
::: {.column width=.5}

How many ways to select $k$ from the $N$ genes?

- Binomial coefficient, choosing $k$ from $N$

$${N \choose k} = \frac{N!}{k! (N-k)!}$$

<!-- - The number of subsets of size $m$ contained in the total set
$[N]$ (i.e., $\{1, \ldots, N\}$) -->

```{r}
N <- 24; k <- 8; choose(N, k)
```

* `r choose(N,k)`

Therefore, the probability of sampling $k$ from $N$ genes uniformly is
$p(N,k) = {N \choose k}^{-1}$

:::
::: {.column width=.5}

Ask how these $k$ genes were distributed with respect to the pathway genes $m$ (the coloured) and the rest of non-pathway genes $n$ (the uncoloured).

- $x$ (of the $k$) from the coloured ($m$), thus ${m \choose x}$

- $k-x$ (of the $k$) from the uncoloured ($n$), thus ${n \choose k-x}$ ways to sample

Summing over all the possibilities:

$p(x,n,m,k) = \frac{{m \choose x } {n \choose k-x}}{{n+m \choose k}}$


```{r include=FALSE}
.m <- 9
.n <- 15
.k <- 8
```

```{r}
dhyper(x=6, m=.m, n=.n, k=.k)
```
* `r dhyper(x=6, m=.m, n=.n, k=.k)`

:::
::::::



## Hypergeometric test for testing significant overlap


Under the null hypothesis:

$$H_{0}:\, x \le x^{\star}$$

We may observe overlap $x^{\star}$ genes by random sampling of $k$ genes **without** replacement.

Therefore, we can calculate the p-value:

$$P(x > x^{\star}|n, m, k) = 1 - \sum_{x = 0}^{x^{\star}} \frac{{m \choose x } {n \choose k-x}}{{n+m \choose k}}$$

In `R`:

```{r eval=FALSE}
phyper(x=6, m=.m, n=.n, k=.k, lower.tail=FALSE)
```


## How significant is $x$ overlap in our discovery?

:::::: {.columns}
::: {.column width=.33}

Fixing $m=$ `r .m`, $n=$ `r .n`, $k=$ `r .k`

```{r fig.width=1.8, fig.height=2.7, echo = FALSE, onslide.plot="1-"}

.dt <- data.table(pp = dhyper(0:8, m=.m, n=.n, k=.k),
                  cc = phyper(0:8, m=.m, n=.n, k=.k),
                  x = 0:8,
                  .null = "0_null")

plot.hyper.cutoff <- function(.dt) {
    
    .y.axis <- scale_y_continuous(breaks=c(0, .3, .6, .9))
    .x.axis <- scale_x_continuous(breaks=0:8)

    p1 <- .gg.plot(.dt, aes(x, pp, fill=.null)) +
        geom_bar(stat="identity") +
        .y.axis + .x.axis + xlab("") +
        scale_fill_manual(values=c("gray","red"), guide="none") +
        ylab("probability")

    p2 <- .gg.plot(.dt, aes(x,cc, fill=.null)) +
        geom_bar(stat="identity") +
        .y.axis + .x.axis + xlab("") +
        scale_fill_manual(values=c("gray","red"), guide="none") +
        ylab("cumulative\nprobability")

    .dt.sig <- .dt %>% filter(.null != "0_null")

    p3 <-
        .gg.plot(.dt, aes(x, 1-cc, fill=.null)) +
        geom_line() +
        geom_point(pch=21) +
        scale_y_sqrt(breaks=c(1,.5, 0.05, 1e-2, 0)) + .x.axis +
        scale_fill_manual(values=c("gray","red"), guide="none") +
        ylab("1 - cumulative\nprobability")

    if(nrow(.dt.sig) > 0){
        p3 <- p3 + geom_text(aes(y=.1 + 1 - cc, label = num.sci(1 - cc)),
                             data = .dt.sig,
                             vjust = 0, hjust = 0,
                             size = 2, angle=90)
    }

    wrap_plots(p1,p2,p3,ncol=1, heights=c(1,1,2))
}

plot.hyper.cutoff(.dt)
```

:::
::: {.column width=.33}

If $x=3$:

```{r fig.width=1.8, fig.height=2.7, echo = FALSE, onslide.plot="2-"}
.dt %>% mutate(.null = if_else(x > 3, "1_alt", "0_null")) %>% 
plot.hyper.cutoff()
```

:::
::: {.column width=.33}

If $x=6$:

```{r fig.width=1.8, fig.height=2.7, echo = FALSE, onslide.plot="3-"}
.dt %>% mutate(.null = if_else(x > 6, "1_alt", "0_null")) %>% 
plot.hyper.cutoff()
```

:::
::::::

## Multiple gene sets, multiple hypothesis testing

:::::: {.columns}
::: {.column width=.5}

Which one is significantly overlapping with $k=8$ genes?

```{r results="asis", out.width="\\linewidth", echo=FALSE}
knitr::include_graphics("./Vis/network/11_network_geneset_6.pdf")
```

:::
::: {.column width=.5}

Measure the tail probability (p-value):

```{r}
mm <- c(9, 7, 11)        # |gene set|
xx <- c(6, 3, 0)         # |overlap|
N <- 24                  # N. total
pval <- phyper(xx,       # overlap
               m=mm,     # inside
               n=(N-mm), # outside 
               k=8,      # significant
               lower.tail=FALSE)
```

Which one is significant?
```{r fig.width=2, fig.height=1, echo=FALSE, onslide.plot="2-"}
.dt <- data.table(pval) %>% mutate(i=1:n())

.gg.plot(.dt, aes(as.factor(i),-log10(pval))) +
    xlab("gene set") +
    geom_bar(stat="identity", width=.25, fill="gray70") +
    geom_text_repel(aes(label=num.sci(pval)), size = 2, colour="red") +
    scale_y_continuous("p-val", labels=function(x) num.sci(10^(-x)))

```

:::
::::::



## Summary of the gene set analysis by hypergeometric test

:::::: {.columns}
::: {.column width=.5}

**When will it work?**

- A routine to construct a set of differentially expressed genes by
  handling multiple hypothesis testing

- Gene sets are of similar sizes and *nearly* disjoint/independent from one another

- Genes are *nearly* independent (there is no overwhelmingly favourite genes)

:::
::: {.column width=.5}

**When will it fail?**

- **Don't** have a good way to make a set:

  - Our discovery data may lack statistical power, i.e., no (or a few)
    significant genes left after multiple hypothesis correction

- There is a hidden factor that can affect two steps: (1) gene set
  selection (annotations/knowledge) and (2) differential expression
  calling

:::
::::::


## Gene Set Enrichment Analysis method (Subramanian _et al._ 2005)

:::::: {.columns}
::: {.column width=.5}

**Rough idea**

Input:

- A collection of gene-sets: $\mathcal{C}_{1}, \ldots, \mathcal{C}_{K}$

- A vector of gene-level scores ($G$ genes): $z_{1}, \ldots, z_{G}$

- Each $z_{g}$ could come from differential expression analysis

Algorithm:

- For each $k$, compute a set-level score $S_{k}(\mathbf{z},\mathcal{C}_{k})$

- E.g., Kolmogorov-Smirnov statistic comparing the distribution $\{z_{g}:\,g \in \mathcal{C}_{k}\}$ vs.  $\{z_{g}:\,g \notin \mathcal{C}_{k}\}$


:::
::: {.column width=.5}

- Construct the null distribution of $S_{1}, \ldots, S_{K}$ by sample label (case-control) or gene-to-set membership permutation

- Using the null distribution by permutation, estimate p-values and false discovery rates

- If we knew the null distribution, we would not need expensive permutations.

**Good**:

- No cutoff/assumptions needed to estimate the null distribution

- Aggregate scores across many genes! (boost the power)

**Bad**:

- What is an appropriate statistic?

- What should be permuted?

:::
::::::

## Let's simulate some gene set data (Efron and Tibshirani 2007)

:::::: {.columns}
::: {.column width=.5}

```{r size="tiny"}
#' Simulate gene sets and expression matrix
#' @param G number of genes
#' @param K number of gene-sets
#' @param n.sample gene expression sample size
#' @param delta gap between the null and alternative
#' @param p.perturb fraction of perturbed genes in the first
simulate.data <- function(G = 1000, K = 150,
                          n.samp = 100, delta = .4,
                          p.perturb = 1) {
    
    case.control <- sample(0:1, n.samp, TRUE) # case control
    S <- sample(K, G, TRUE)                   # gene sets
    X <- .rnorm(n.samp, G)                    # All the other genes

    ## Perturbation of the first gene set
    .genes.1 <- which(S == 1)
    n.perturb <- max(floor(length(.genes.1) * p.perturb), 1)
    .genes.1 <- sample(.genes.1, n.perturb)
    .case <- case.control == 1
    X[.case, .genes.1] <- X[.case, .genes.1] + delta
    .membership <- Matrix::sparseMatrix(j=1:G, i=S, x=rep(1,G))
    list(X = X, S = .membership, Y = case.control)
}
```

:::
::: {.column width=.55}

* Generate basal gene expression 

$$X_{i,g} \sim \mathcal{N}\!\left(0,1\right)$$

* Sample case vs. control membership (the rows of $X$) uniformly at random

* Sample membership gene to gene set uniformly at random 

* For the first gene set, select a certain fraction of genes to perturb

* For the selected genes $g^{*}$, add some $\Delta$ value to $X_{i,g^*}$ if the sample $i$ belongs to the control group

:::
::::::

## Will a simple analytical method work?

:::::: {.columns}
::: {.column width=.5}

```{r}
set.seed(1)
.dat <- simulate.data()

geneset.score <- function(X, S, Y) {
    .case <- Y == 1
    .ctrl <- Y == 0
    .fun <- function(x)
        t.test(x[.case],
               x[.ctrl])$statistic
    z.genes <- apply(X, 2, .fun)
    n.sets <- apply(S, 1, sum)
    z.sets <- (S %*% z.genes /
               sqrt(n.sets))
}
```

:::
::: {.column width=.55}

* Irizarry _et al._ (2009), using Stouffer Z-score

$$S_{k} =\sum_{g \in \mathcal{C}_{k}} z_{g} /  \sqrt{|\mathcal{C}_{k}|}$$

```{r}
z.sets <- geneset.score(.dat$X,
                        .dat$S,
                        .dat$Y)
```

```{r include=FALSE}
.qq.norm <- function(zz){
    .qq <- qqnorm(as.numeric(zz), plot.it=FALSE)
    .dt <- setDT(.qq)
    .dt.sig <- .dt[abs(y) > 2 & abs(y) > 1.25*abs(x)]
    .gg.plot(.dt, aes(x,y)) +
        geom_point(stroke=0, size=.7) +
        geom_point(data=.dt.sig, size=2, pch=21, colour="red") +
        geom_abline(slope=1, colour=2) +
        xlab("z ~ N(0,1)") +
        ylab("observed z-scores")
}
```


```{r fig.width=2, fig.height=1.25, echo=FALSE, only.plot="2"}
.qq.norm(z.sets)
```

```{r include=FALSE}
.pv.plot <- function(zz) {
    .dt <- data.table(z = as.numeric(zz)) %>%
        mutate(i = 1:n()) %>%
        mutate(pv = 2 * pnorm(abs(z), lower.tail=FALSE)) %>%
        mutate(l10.pv = -log10(pv))
    .dt.sig <- .dt[pv < 1e-2]
    .gg.plot(.dt, aes(as.factor(i),l10.pv)) +
        geom_point(stroke=0, size=.7) +
        geom_point(data=.dt.sig, size=2, pch=21, colour="red") +
        theme(axis.text.x = element_blank()) +
        theme(axis.ticks.x = element_blank()) +
        geom_hline(yintercept = -log10(0.01), colour="red", lty=2) +
        xlab("gene sets") +
        scale_y_continuous("p-val",
                           labels=function(x) num.sci(10^(-x)))
}
```

```{r fig.width=2, fig.height=1.25, echo=FALSE, only.plot="3"}
.pv.plot(z.sets)
```

:::
::::::


## Constructing the null distribution by gene permutation

:::::: {.columns}
::: {.column width=.65}


```{r}
S.perm <- t(apply(.dat$S, 1, sample))
z.perm <- geneset.score(.dat$X, S.perm, .dat$Y)
```

```{r fig.width=3.5, fig.height=1.25, echo=FALSE}
.qq.norm(z.perm) | .pv.plot(z.perm)
```

:::
::: {.column width=.35}

* Repeat the permutation of gene set membership matrix while
  preserving the number of genes within each set

* Compute set-level z-scores (or a similar kind) and construct the null
  distribution

* Calculate p-values by counting the frequency of observed $S_{k}^{*} > S_{k}^{\textsf{perm}}$

:::
::::::

## Constructing the null distribution by sample permutation

:::::: {.columns}
::: {.column width=.65}


```{r}
Y.perm <- sample(.dat$Y)
z.perm <- geneset.score(.dat$X, S.perm, Y.perm)
```

```{r fig.width=3.5, fig.height=1.25, echo=FALSE}
.qq.norm(z.perm) | .pv.plot(z.perm)
```

:::
::: {.column width=.35}

* Repeat the permutation of case-control labels while
  preserving the same number of cases and controls

* Compute set-level z-scores (or a similar kind) and construct the null
  distribution

* Calculate p-values by counting the frequency of observed $S_{k}^{*} > S_{k}^{\textsf{perm}}$

:::
::::::


# Biological network analysis

## What is network? Some graph theory terms

* Network is a graph, which is a set of sets

* We define a graph as a tuple $G = (V, E)$ if undirected:

    * V (or $V(G)$): a set of vertices, $V = \{v_{1}, \ldots, v_{n}\}$

    * E (or $E(G)$): a set of edges, $E = \{(v_{i}, v_{j}):\, \textsf{if vertices } i,j \textsf{ are conected}\}$

* $n(G) = |V(G)|$ number of the vertices in $G$, the size of the set $V$ (or simply $n$)

* $m(G) = |E(G)|$ number of the edges (connected pairs) in $G$, the size of the set $E$ (or simply $m$)

* $d_{v}(G)=$ degree of a vertex $v$'s neighbours in $G$ (# how many friends?)

## We can use `igraph` in `R`

```{r size = "Huge"}
library(igraph)
```

* We can use `igraph` in `R` or `Python` or `C++`.

## Let's take a look at some classic examples

Download some from Mark Newman's website:

\vspace{10pt}

```{r size = "tiny"}
#' @param .src www location
#' @param .dir downloading local directory
#' @param .zip zip file name
#' @param .tgt target gml file name
.read.online <- function(.src,
                         .dir="Data/",
                         .zip = str_c(.dir,basename(.src)),
                         .tgt = str_replace(.zip, "zip$", "gml")){
    if(!file.exists(.tgt)){
        .gml <- basename(.tgt)                     # remove the dir name
        download.file(.src, .zip)                  # download from the web
        unzip(.zip, files=.gml, exdir = .dir)      # unzip
    }
    return(igraph::read_graph(.tgt, format="gml")) # read them into memory
}
```

```{r size = "scriptsize"}
karate <- .read.online("http://www-personal.umich.edu/~mejn/netdata/karate.zip")
polblog <- .read.online("http://www-personal.umich.edu/~mejn/netdata/polblogs.zip")
netsci <- .read.online("http://www-personal.umich.edu/~mejn/netdata/netscience.zip")
football <- .read.online("http://www-personal.umich.edu/~mejn/netdata/football.zip")
condmat <- .read.online("http://www-personal.umich.edu/~mejn/netdata/cond-mat-2005.zip")
```

## Handy functions for visualizing a network

We want to match graph vertices with the layout coordinates found by
`igraph::layout_nicely` and make it easy to show in `ggplot` or something else.

:::::: {.columns}
::: {.column width=.5}

```{r}
#' @param G igraph object
#' @param layout.file local file
find.nice.layout <-
    function(G, layout.file) {

    if(!file.exists(layout.file)){
        layout.dt <-
            layout_nicely(G) %>%
            as.data.table()
        saveRDS(layout.dt, layout.file)
    }
    readRDS(layout.file)
}
```

:::
::: {.column width=.5}

```{r}
#' @param G igraph object
#' @param .name file header
apply.layout.dt <- function(G, .name){
  .out.file <-
    str_c(fig.dir,"/",.name,".rds")

  .out <-
    find.nice.layout(G, .out.file) %>%
    dplyr::mutate(v = 1:dplyr::n()) # index

  as_long_data_frame(G) %>%
    as.data.table %>% 
    merge(.out, by.x= "from", by.y="v") %>%
    merge(.out, by.x= "to", by.y="v",
        suffixes=c(".from",".to"))
}
```

:::
::::::

## Plotting a graph with points and segments in `ggplot`

```{r size = "tiny"}
plot.layout.dt <- function(.dt, .palette="Paired", .palette.e = "Set2", .esize = .5, .vsize = 5, .add.lab=TRUE){
  if(!("k.from" %in% colnames(.dt))) .dt[, k.from := 1]                    # add membership
  if(!("k.to" %in% colnames(.dt))) .dt[, k.to := 1]                        # add membership
  .rename <- function(xx) { colnames(xx) <- c("v","V1","V2","k"); xx }     # Find a consolidated
  .dt.v <-                                                                 # set of vertices
    rbind(.dt[, .(`from`, `V1.from`, `V2.from`, `k.from`)] %>% .rename(),
        .dt[, .(`to`, `V1.to`, `V2.to`, `k.to`)] %>% .rename()) %>%
    dplyr::mutate(k = as.factor(k)) %>% unique
                                              
  .aes.e <- aes(V1.from, V2.from, xend=V1.to, yend=V2.to)   # edge colours
  if("k.edge" %in% colnames(.dt)) {
    .aes.e <- aes(V1.from, V2.from, xend=V1.to, yend=V2.to, colour=as.factor(k.edge))
  }
  plt <- ggplot() + theme_void()                                           # show no axis
  if("k.edge" %in% colnames(.dt)) {
    plt <- plt +
      geom_segment(.aes.e, data = .dt, size = .esize) +                    # draw edges
      scale_colour_brewer(palette=.palette.e, na.value="grey", guide="none")
  } else {
    plt <- plt +
      geom_segment(.aes.e, data = .dt, size = .esize, colour="gray")       # draw edges
  }
  plt <- plt +
    geom_point(aes(V1, V2, fill=k), data = .dt.v, pch=21, stroke=.1, size = .vsize) + # vertices
    scale_fill_brewer(palette = .palette, guide="none")                    # vertex colouring

  if(.add.lab){ plt <- plt + geom_text(aes(V1, V2, label=v), data = .dt.v, size = 3) }
  return(plt)
}
```

## Social network examples 

:::::: {.columns}
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=2}
.vv <- V(polblog)[degree(polblog) >= 3]
polblog.sub <- induced_subgraph(polblog, .vv)
apply.layout.dt(polblog.sub, "polblog.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=2, .esize=.2)
```

* L. A. Adamic and N. Glance, "The political blogosphere and the 2004 US Election", in Proceedings of the WWW-2005 Workshop on the Weblogging Ecosystem (2005).

:::
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=2}
.comp <- components(netsci)
.vv <- V(netsci)[.comp$membership == which.max(.comp$csize)]
netsci.sub <- induced_subgraph(netsci, .vv)

apply.layout.dt(netsci.sub, "netsci.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=2, .esize=.2)
```

* Coauthorship network of scientists working on network theory and experiment

* Showing only the largest component

* M. Newman in May 2006.

:::
::::::

## More examples

:::::: {.columns}
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=1.8}
.vv <- V(football)[degree(football) >= 3]
football.sub <- induced_subgraph(football, .vv)
apply.layout.dt(football.sub, "football.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=2, .esize=.2)
```

* Network of American football games between Division IA colleges during regular season Fall 2000. 

* M. Girvan and M. E. J. Newman, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002).

:::
::: {.column width=.5}

```{r echo = FALSE, fig.width=2, fig.height=1.8}
G <- condmat

apply.degree.cutoff <- function(G, .cutoff = 5) {
    .sub <- G
    .rr <- sum(degree(.sub) < .cutoff)
    while(.rr > 0){
        vv <- V(.sub)
        .vv <- vv[degree(.sub) >= .cutoff]
        .sub <- induced_subgraph(.sub, .vv)
        .rr <- sum(degree(.sub) < .cutoff)
    }
    return(.sub)
}

condmat.sub <- apply.degree.cutoff(G)
apply.layout.dt(condmat.sub, "condmat.sub") %>%
    plot.layout.dt(.add.lab=FALSE, .vsize=.3)
```

* Co-authorships between scientists posting preprints on the Condensed Matter E-Print Archive. M. Newman, PNAS (2001).

* Showing densely-connected part (iterative degree cutoff >= 5)

:::
::::::

## Biological network: Human Reference Protein-Protein interaction map

:::::: {.columns}
::: {.column width=.5}

* Download the data from `interactome-atlas.org`

```{r}
db.url <- "http://www.interactome-atlas.org"
ppi.net.file <- "Data/HI-union.tsv.gz"
if(!file.exists(ppi.net.file)){
    .file <- str_remove(ppi.net.file, "[.]gz$")
    .url <- str_c(db.url,"/data/HI-union.tsv")
    download.file(.url, destfile = .file)
    R.utils::gzip(.file)
}
```

* Build a network from a list of interacting pairs

```{r}
ppi.pairs <-
  fread(ppi.net.file,
        header=FALSE,
        col.names=c("v1","v2")) %>%
  filter(v1 != v2) %>% as.matrix

G.ppi <-
  graph_from_edgelist(ppi.pairs, directed = FALSE)
```

:::
::: {.column width=.45}

* Vertices: genes (or the resulting proteins)

* Edges: two or multiple genes work together (could have many different meanings)

```{r}
n <- length(V(G.ppi))
m <- length(E(G.ppi))
```

* n = `r n` vertices

* m = `r m` edges

:::
::::::

## Biological network: Human Reference Protein-Protein interaction map

:::::: {.columns}
::: {.column width=.5}

```{r echo=FALSE, fig.width=3, fig.height=3}
apply.layout.dt(G.ppi, "ppi") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::: {.column width=.45}

* Vertices: genes (or the resulting proteins)

* Edges: two or multiple genes work together (could have many different meanings)

```{r}
n <- length(V(G.ppi))
m <- length(E(G.ppi))
```

* n = `r n` vertices

* m = `r m` edges

Sources of biological networks:

* High-throughput experiments

* Co-expression analysis

* Literature-based curation

:::
::::::

## Degree distribution (How many friends?)

:::::: {.columns}
::: {.column width=.65}

For each vertex $v \in V(G)$: $d_{v} = \sum_{u} A_{uv}$

* It is simple to calculate in `igraph`:

```{r}
deg.dt <- degree(G.ppi) %>% 
    (function(.d)
        data.table(d=.d, v = names(.d))
    )
```

* Degree distributions may teach us the underlying generative scheme

* Power-law (almost linear slope in a log-log plot) may indicate a "rich-get-richer" phenomenon.

* The majority with $< 10$ neighbours vs. hub nodes with $> 100$ neighbours

* Poisson distribution if edges are drawn uniformly at random

:::
::: {.column width=.35}

A handy one-liner:

```{r}
.dt <- deg.dt[, .(count=.N), by=.(d)]
```

Log-log plot:

```{r fig.width=2, fig.height=1.5}
.gg.plot(.dt, aes(x=`d`, y=`count`)) +
    geom_point(stroke=0) +
    scale_x_log10() +
    scale_y_log10()
```

:::
::::::

## Connected components and a giant component

:::::: {.columns}
::: {.column width=.6}

```{r echo=FALSE, fig.width=3, fig.height=3}
apply.layout.dt(G.ppi, "ppi") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::: {.column width=.4}

A (connected) component = a set of vertices reachable by hopping
through edges.

```{r}
.comp <- components(G.ppi)
```

Found `r .comp$no` connected components

```{r echo = FALSE, results="asis"}
.dt <- data.table(n=.comp$csize);
knitr::kable(.dt[, .(count=.N), by=.(`n`)])
```

* Can we take the giant one?

```{r}
k <- which.max(.comp$csize)
.sub <-
    names(.comp$membership)[
        .comp$membership==k
    ]
G.ppi.sub <- induced_subgraph(G.ppi, .sub)
```

:::
::::::

## A subgraph induced by genes/proteins in the giant component

:::::: {.columns}
::: {.column width=.64}

```{r echo=FALSE, fig.width=4, fig.height=3}
apply.layout.dt(G.ppi.sub, "ppi-giant") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::: {.column width=.35}

* $n(G)$: `r length(V(G.ppi.sub))` (vs. `r length(V(G.ppi))`)

* $m(G)$: `r length(E(G.ppi.sub))` (vs. `r length(E(G.ppi))`)

* Degree distribution:

```{r echo=FALSE, fig.width=2, fig.height=2}
.dt <- data.table(d=degree(G.ppi.sub))
.dt <- .dt[, .(count = .N), by = .(d)]
.gg.plot(.dt, aes(x=d, y=count)) + geom_point(stroke=0) + scale_x_log10() + scale_y_log10()
```

:::
::::::

## Iterative degree cutoff to remove dangling vertices

:::::: {.columns}
::: {.column width=.5}

We may consider this as a Q/C step:

```{r}
degree.cutoff <- function(G, .cutoff = 3) {
    G.sub <- G
    n.remove <- sum(degree(G.sub) < .cutoff)
    while(n.remove > 0){
        vv <- V(G.sub)
        .retain <- vv[degree(G.sub) >= .cutoff]
        G.sub <- induced_subgraph(G.sub, .retain)
        n.remove <- sum(degree(G.sub) < .cutoff)
    }
    return(G.sub)
}

G.dc <- degree.cutoff(G.ppi.sub, 3)
```

Comparison with the raw PPI data:

* $n(G)$: `r length(V(G.dc))` (vs. `r length(V(G.ppi))`)

* $m(G)$: `r length(E(G.dc))` (vs. `r length(E(G.ppi))`)

:::
::: {.column width=.5}

Will it look nicer?

```{r echo=FALSE, fig.width=2, fig.height=1.5}
apply.layout.dt(G.dc, "ppi-dc") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

:::
::::::


## Iterative degree cutoff to remove dangling vertices

:::::: {.columns}
::: {.column width=.5}

Degree distribution:

```{r echo=FALSE, fig.width=2, fig.height=2}
.dt <- data.table(d=degree(G.dc))
.dt <- .dt[, .(count = .N), by = .(d)]
.gg.plot(.dt, aes(x=d, y=count)) + geom_point(stroke=0) + scale_x_log10() + scale_y_log10()
```

* $n(G)$: `r length(V(G.dc))` (vs. `r length(V(G.ppi))`)

* $m(G)$: `r length(E(G.dc))` (vs. `r length(E(G.ppi))`)

* Note: $d$ starts from `3`

:::
::: {.column width=.5}

Will it look nicer?

```{r echo=FALSE, fig.width=2, fig.height=1.5}
apply.layout.dt(G.dc, "ppi-dc") %>% plot.layout.dt(.add.lab=FALSE, .vsize=1, .esize=.1)
```

* Rationale: no genes act alone. If some genes have significantly fewer edges connected, high-throughput experiments had not covered them sufficiently.

:::
::::::

<!------------->
<!-- Network -->
<!------------->

# Random walk: What can networks teach us?


## Gene prioritization: a toy example of multiple sclerosis GWAS

:::::: {.columns}
::: {.column width=.5}

We can download public data mapping SNPs (genes) to diseases/phenotypes from [the NHGRI-EBI GWAS Catalog](https://www.ebi.ac.uk/gwas/)

* GWAS: genome-wide association study (will cover later)

```{r echo = FALSE}
.url <- "https://www.ebi.ac.uk/gwas/api/search/downloads/alternative"
.gwas.catalog.file <- "Data/gwas_catalog_v1.0.2-associations_e105_r2021-12-21.tsv.gz"
if(!file.exists(.gwas.catalog.file)){
    .file <- stringr::str_remove(.gwas.catalog.file, ".gz$")
    download.file(.url, destfile = .file)
    R.utils::gzip(.file)
}
```

Let's retrieve a list of MS-related genes

```{r size="tiny"}
.gwas.dt <- fread(.gwas.catalog.file,
                  sep="\t", quote="")

is.ms.trait <- function(x)
  str_detect(x, "[Mm]ultiple sclerosis")

ms.genes <-
 .gwas.dt[is.ms.trait(`DISEASE/TRAIT`),] %>%
 filter(str_length(`MAPPED_GENE`) > 2) %>% 
 select(`MAPPED_GENE`) %>%
 na.omit %>% 
 unlist %>%
 str_split(pattern="[ ,;]+" ) %>%
 unlist %>%
 unique
```


```{r echo = FALSE}
read.ensembl.info <- function(ensg, .file = str_c(fig.dir, "/ensembl.RDS")) {
    
    if(file.exists(.file)) { return(readRDS(.file)) }

    .mart <- biomaRt::useMart(biomart='ENSEMBL_MART_ENSEMBL',
                                host='uswest.ensembl.org',
                                path='/biomart/martservice',
                                dataset='hsapiens_gene_ensembl')
    
    ensembl.hs = biomaRt::useDataset('hsapiens_gene_ensembl', .mart)

    .attr <- c('ensembl_gene_id', 'hgnc_symbol', 'go_id',
               'name_1006', 'namespace_1003')

    .dt <- biomaRt::getBM(attributes=.attr,
                          filters='ensembl_gene_id', values=ensg,
                          mart=ensembl.hs, useCache = FALSE)

    saveRDS(unique(as.data.table(.dt)), .file)
    return(.dt)
}
gene.info <- read.ensembl.info(names(V(G.ppi)))
```

:::
::: {.column width=.5}

How many of them overlap with the vertices in the PPI network?

```{r}
vtot <- V(G.ppi)
v.dt <- data.table(v=vtot,ensembl_gene_id=names(vtot))
.dt <- merge(v.dt, gene.info)
overlap.dt <-
  .dt[hgnc_symbol %in% ms.genes,
      .(v, ensembl_gene_id, hgnc_symbol)
     ] %>% unique
```

* `r nrow(overlap.dt)` genes (of `r length(ms.genes)` MS genes)
  recapitulated in the network

* That is a small fraction compared to the total `r length(V(G.ppi))`
  genes in the network

* What if no mutations occurred in other relevant genes? No mutation
  $\to$ no association.

:::
::::::



## Mapping disease genes onto a gene-gene interaction network

:::::: {.columns}
::: {.column width=.5}

Revisiting the gene-gene (protein-protein) interaction network

\vspace{12pt}

```{r echo = FALSE, fig.width=2, fig.height=2, onslide.plot="1-"}
.dt <- apply.layout.dt(G.ppi, "ppi")
.dt[, k.from := "2_WT"]; .dt[, k.to := "2_WT"]
.dt[`to` %in% overlap.dt$v, k.to := "1_MS"]
.dt[`from` %in% overlap.dt$v, k.from := "1_MS"]

plot.layout.dt(.dt, .palette = "RdBu", .add.lab=FALSE, .vsize=1, .esize=.05)
```

* Where are my GWAS genes in the network? 

:::
::: {.column width=.5}

```{r echo = FALSE}
.dt <- apply.layout.dt(G.ppi, "ppi")

.x.scale <- 
    scale_x_continuous(limits = c(min(.dt$V1.from), max(.dt$V1.to)))

.y.scale <- 
    scale_y_continuous(limits = c(min(.dt$V2.from), max(.dt$V2.to)))
```

```{r echo = FALSE, fig.width=2, fig.height=2, only.plot="2"}
vset <- overlap.dt$v

.dt.sub <- .dt[`to` %in% vset & `from` %in% vset, ]

plt <- plot.layout.dt(.dt.sub, .palette = "RdBu",
                      .add.lab=FALSE, .vsize=2, .esize=.5)

.title <- str_c(nrow(overlap.dt), " MS GWAS genes\n(",
                round(100 * length(vset) / length(V(G.ppi))), "%)")

plt.ms.gwas <- plt + .x.scale + .y.scale + ggtitle(.title) + theme(title=element_text(size=8))
print(plt.ms.gwas)
```

```{r echo = FALSE}
.neigh <- function(vv, nn){
    lapply(vv, function(v) neighbors(G.ppi, v, mode="all")) %>% 
    do.call(what = c) %>% unique
}
```

```{r echo = FALSE, fig.width=2, fig.height=2.1, only.plot="3"}
v.neigh <- .neigh(overlap.dt$v)

vset <- union(v.neigh, overlap.dt$v)

.dt.sub <- .dt[`to` %in% vset &
                `from` %in% vset, ]

plt <- plot.layout.dt(.dt.sub, .palette = "RdBu",
                      .add.lab=FALSE, .vsize=1, .esize=.5)

.title <- str_c(length(vset), ", MS genes+\nimmediate neighbours\n(",
                round(100 * length(vset) / length(V(G.ppi))), "%)")

plt + .x.scale + .y.scale + ggtitle(.title) + theme(title=element_text(size=8))
```


```{r echo = FALSE, fig.width=2, fig.height=2.1, only.plot="4"}
v.neigh <- .neigh(vset)

vset <- union(v.neigh, vset)

.dt.sub <- .dt[`to` %in% vset &
                `from` %in% vset, ]

plt <- plot.layout.dt(.dt.sub, .palette = "RdBu",
                      .add.lab=FALSE, .vsize=1, .esize=.5)

.title <- str_c(length(vset), " MS genes\nneighbours in two hops\n(",
                round(100 * length(vset) / length(V(G.ppi))), "%)")

plt + .x.scale + .y.scale + ggtitle(.title) + theme(title=element_text(size=8))
```

* Genes immediately hit by GWAS are *not* probably comprehensive enough.

* Are they all relevant if we extend the set of candidate genes? How far?

:::
::::::

## Can we prioritize disease-relevant genes using PPI network?

:::::: {.columns}
::: {.column width=.5}

* GWAS might cover too few candidate genes...

* Naively expanding the set by all the neighbourhood would be too many...

* Not all the neighbours are affected by the disease... 

* Who are the relevant neighbours?

* **Network $\approx$ Information flow diagram**

* Spreading "labels" in the information network

:::
::: {.column width=.5}

:::
::::::

## Random walk probability: What are the probabilities of visiting neighbours?

:::::: {.columns}
::: {.column width=.5}

A wrapper function for `igraph`'s `random_walk()`

```{r}
.rand.walk <- function(vv, nn){
  .fun <-
    function(v) 
      random_walk(G.ppi, v, nn, mode="all")
  lapply(vv, .fun) %>%
      do.call(what = c) %>%
      unique
}
```

Let's take five steps from the MS genes:

```{r}
v0 <- overlap.dt$v # seed
v.1 <- .rand.walk(v0,1)
v.2 <- .rand.walk(v0,2)
v.3 <- .rand.walk(v0,3)
```

```{r echo = FALSE}
n.1 <- v0
nn <- .neigh(v0)
n.2 <- nn
nn <- .neigh(nn)
n.3 <- nn
```

:::
::: {.column width=.5}

Some vertices are more frequently visited when we randomly traverse in the network.


```{r echo=FALSE, fig.width=2, fig.height=2, only.plot=1}
.build.dt.sub <- function(.dt, vv, nn) {
    .vset <- c(vv, nn)
    .dt.sub <- .dt[`to` %in% .vset & `from` %in% .vset]
    .dt.sub[`to` %in% vv, k.to := "r"]
    .dt.sub[`from` %in% vv, k.from := "r"]
    .dt.sub[`to` %in% vv & `from` %in% vv, k.edge := "r"]
    rbind(.dt.sub[is.na(k.edge), ],
          .dt.sub[!is.na(k.edge), ])
}
.dt <- apply.layout.dt(G.ppi, "ppi")
.dt.sub <- .build.dt.sub(.dt, v.1, n.1)
plot.layout.dt(.dt.sub, .palette="RdBu", 
               .add.lab = FALSE, .vsize=1, .esize=.5) +
    ggtitle(str_c("n=", length(v.1), " / ", length(n.1))) +
    theme(title=element_text(size=8)) +
    .x.scale + .y.scale
```

```{r echo=FALSE, fig.width=2, fig.height=2, only.plot=2}
.dt.sub <- .build.dt.sub(.dt, v.2, n.2)
plot.layout.dt(.dt.sub, .palette="RdBu", 
               .add.lab = FALSE, .vsize=1, .esize=.5) +
    ggtitle(str_c("n=", length(v.2), " / ", length(n.2))) +
    theme(title=element_text(size=8)) +
    .x.scale + .y.scale
```

```{r echo=FALSE, fig.width=2, fig.height=2, only.plot=3}
.dt.sub <- .build.dt.sub(.dt, v.3, n.3)
plot.layout.dt(.dt.sub, .palette="RdBu", 
               .add.lab = FALSE, .vsize=1, .esize=.5) +
    ggtitle(str_c("n=", length(v.3), " / ", length(n.3))) +
    theme(title=element_text(size=8)) +
    .x.scale + .y.scale
```

:::
::::::

## What are the probabilities of visits from the disease genes?

:::::: {.columns}
::: {.column width=.5}

* We can represent the network as an adjacency matrix $A$, where $A_{ij}=1$ if vertices $i$ and $j$ are connected.

* Define a weight matrix $W_{ij} = Pr(j \to i)$ with equal probabilities, i.e., $W_{ij} \gets A_{ij} / \sum_{i} A_{ij}$.

$$\mathbf{p}^{(t)} \gets \gamma W \mathbf{p}^{(t-1)} + (1- \gamma) \mathbf{p}^{(0)}$$

* We initialize $\mathbf{p}^{(0)}$ by the disease genes, setting $p_{i} = 1/\#$ disease genes if a gene $i$ is in the MS GWAS.

```{r echo = FALSE, fig.width=2.8, fig.height=.7}
.v <- as.integer(overlap.dt$v)
n <- length(V(G.ppi))
pr <- matrix(0, n, 1)
pr[.v, 1] <- 1
pr.0 <- pr / sum(pr)

.dt <- data.table(v=as.integer(V(G.ppi)), pr=as.numeric(pr.0))
.gg.plot(.dt, aes(v,pr)) + geom_line() + ylab("p(0)") + xlab("vertices")
```

:::
::: {.column width=.5}

The code is actually simpler than explanation:

```{r}
A <- as_adjacency_matrix(G.ppi)
d <- degree(G.ppi)
W <- sweep(A, 2, d, `/`)
```

Take `100` random walks:

```{r}
pr <- pr.0; r <- 0.85
P <- matrix(NA, n, 100)
P[,  1] <-  as.numeric(pr)
for(tt in 1:99) {
    pr <- r * W %*% pr + (1 - r) * pr.0
    pr <- pr / sum(pr)
    P[, tt + 1] <-  as.numeric(pr)
}
```

```{r echo = FALSE, fig.width=2.8, fig.height=1}
.dt <- data.table(v=as.integer(V(G.ppi)), pr=as.numeric(P[, 100]))
.gg.plot(.dt, aes(v,pr)) + geom_line() + ylab("p(100)") + xlab("vertices")
```

:::
::::::

## Top 50 genes identified by random walk from MS GWAS

```{r echo = FALSE, fig.width=3, fig.height=3}
vtot <- V(G.ppi)
v1 <- vtot[order(P[,100], decreasing=TRUE)[1:50]]
G.sub <- induced_subgraph(G.ppi, v1)
.dt <- apply.layout.dt(G.sub, "ppi_ms")

plot.layout.dt(.dt, .add.lab=FALSE, .vsize=2, .esize=.5)
```

## Are simply we recapitulating high-degree vertices?

```{r echo=FALSE, fig.width=3, fig.height=2.5}
.dt <- data.table(v=as.integer(V(G.ppi)),
                  d=degree(G.ppi),
                  pr=as.numeric(P[, 100]))

.dt.top <- .dt %>% arrange(desc(pr)) %>% head(100)

.gg.plot(.dt, aes(d,pr)) +
    geom_hex(aes(fill = stat(log10(count)))) +
    geom_point(data = .dt.top, colour="red", pch=21) +
    geom_smooth(method="lm", se=FALSE, size=.5, colour="black", lty=2) +
    scale_fill_distiller("count", direction = 1, labels=function(x) round(10^x)) +
    theme(legend.key.width=unit(.2, "lines")) +
    theme(legend.key.height=unit(.5, "lines")) +
    scale_x_log10() +
    scale_y_log10() +
    ylab("p(100)") +
    xlab("degree")
```

Red dots: top 100 genes.

<!---------------------------->
<!-- stochastic block model -->
<!---------------------------->

# Learning structures in networks

## Some useful packages in `R`

We can use `igraph` in `R` or `Python` or `C++`.

```{r}
library(igraph)
```

This is my own R/C++ package that can find a stochastic block model in an adjacency matrix.

```{r eval=FALSE}
remotes::install_github("YPARK/hsblock")
```

```{r}
library(hsblock)
```

## Community detection in Zachary's karate club (motivating example)

:::::: {.columns}
::: {.column width=.45}

* Social network of friendships between 34 members of a karate club at a US university in the 1970s.

* W. W. Zachary, An information flow model for conflict and fission in small groups, Journal of Anthropological Research 33, 452-473 (1977).

```{r echo = FALSE}
karate <- .read.online("http://www-personal.umich.edu/~mejn/netdata/karate.zip")
```

* **Vertex**: a member in the karate club; **edge**: friendship

* How many samples?

* What is the dimensionality?

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=2}
.karate.dt <- apply.layout.dt(karate, "karate")
plot.layout.dt(.karate.dt)
```

:::
::::::

## A graph-theoretic approach: Community detection by discrete optimization

:::::: {.columns}
::: {.column width=.45}

* Consider two groups

* Find a set of edges to induce two disconnected components

* Not so ideal for a sparse, irregular graph

:::
::: {.column width=.45}

A trivial solution (min cut = 1)

```{r echo = FALSE, fig.width=2, fig.height=2}
.dt <- apply.layout.dt(karate, "karate")
.dt[, k.to := 1]
.dt[, k.from := 1]
.dt[`from` == 12, k.from := 2]
.dt[`to` == 12, k.to := 2]

plot.layout.dt(.dt)
```

:::
::::::


## Who are the "influencers" in the karate club?

:::::: {.columns}
::: {.column width=.45}

* Network is not just a mathematical object

* Vertices and edges have a meaning

* Member __1__: the instructor ("Mr. Hi"), probably the founder?

* Member __34__: the president (John A)

* Member __33__: perhaps working with the present (similar interaction patterns)

:::
::: {.column width=.45}

A trivial solution (min cut = 1)

```{r echo = FALSE, fig.width=2, fig.height=2}
.dt <- apply.layout.dt(karate, "karate")
.dt[, k.to := 1]
.dt[, k.from := 1]
.dt[`from` == 12, k.from := 2]
.dt[`to` == 12, k.to := 2]
.dt[`from` %in% 1, k.from := 3]
.dt[`to` %in% 1, k.to := 3]
.dt[`from` %in% c(33, 34), k.from := 4]
.dt[`to` %in% c(33, 34), k.to := 4]

plot.layout.dt(.dt)
```

:::
::::::


## Finding min-cuts from the source to target vertices

:::::: {.columns}
::: {.column width=.45}

```{r}
.cuts <- as.directed(karate) %>% 
    st_min_cuts(source = "1", target = c("33","34"))
.sets <- .cuts[["partition1s"]] %>%
    lapply(as.character)
```

* Multiple solutions with the same min-cut=`r .cuts$value/2` edges.

* A partition from "1":

```{r results="asis"}
str_c(sort(.cuts$partition1s[[1]]), collapse=", ")
```

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=2}
.dt <- apply.layout.dt(karate, "karate") %>%
    mutate(k.from = 0, k.to = 0)

.dt[`from` %in% .sets[[1]], k.from := 2]
.dt[`to` %in% .sets[[1]], k.to := 2]
plot.layout.dt(.dt)
```

:::
::::::


## Finding min-cuts from the source to target vertices -- 2

:::::: {.columns}
::: {.column width=.45}

* Multiple solutions with the same min-cut=`r .cuts$value/2` edges.

* A partition from "1":

```{r results="asis"}
str_c(sort(.cuts$partition1s[[2]]), collapse=", ")
```

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=2}
.v2 <- setdiff(.sets[[2]], .sets[[1]])
.dt[`from` %in% .v2, k.from := 3]
.dt[`to` %in% .v2, k.to := 3]
plot.layout.dt(.dt)
```

:::
::::::


## Finding min-cuts from the source to target vertices -- 3

:::::: {.columns}
::: {.column width=.45}

* Multiple solutions with the same min-cut=`r .cuts$value/2` edges.

* A partition from "1":

```{r results="asis"}
str_c(sort(.cuts$partition1s[[3]]), collapse=", ")
```

* Can we identify group/block structures without the vertex labels (e.g., source and target)?

:::
::: {.column width=.45}

```{r echo = FALSE, fig.width=2, fig.height=2}
.v3 <- setdiff(setdiff(.sets[[3]], .sets[[2]]), .sets[[1]])
.dt[`from` %in% .v3, k.from := 4]
.dt[`to` %in% .v3, k.to := 4]
plot.layout.dt(.dt)
```

:::
::::::

## A generative modelling approach: Stochastic block model (network is an adjacency matrix)

:::::: {.columns}
::: {.column width=.45}

(vertex x vertex)

```{r fig.width=2, fig.height=2}
A <- as_adjacency_matrix(karate)
.matshow(A, .scale=FALSE, .lab = 0)
```

:::
::: {.column width=.45}

* **Row/column**: a member in the karate club

* **non-zero element**: friendship between the row and column

* How many samples? What is the dimensionality?

* Can you see group structures?

* Most of $A_{ij} = 0$. Otherwise, there is no reason to consider this matrix as a network.

:::
::::::

## Stochastic block model: membership $Z$ and parameter $\Theta$ 

:::::: {.columns}
::: {.column width=.7}

```{r}
.out <- fit.hsblock(A, "bernoulli", vbiter=100, inner.iter=10, verbose=FALSE)
Z <- as.matrix(.out$Z)          # Cluster x vertex
n <- ncol(Z)                    # Number of vertices
Edges <- 0.5 * Z %*% A %*% t(Z) # Num of edges within/between clusters
.ones <- matrix(1,n,n)          # Total num of pairs
diag(.ones) <- 0                # without cycles
Tot <- Z %*% .ones %*% t(Z)/2   # 
Pr <- Edges / Tot               # Probability of edges within/between clusters
```
:::
::: {.column width=.3}

* Latent var.: $Z_{ki} = 1$ iff a vertex $i$ $\to$ a cluster $k$

* Model parameters: $\theta_{kk'} \in (0,1)$: pr of edges between $k$ and $k'$

:::
::::::

<!-- :::::: {.columns} -->
<!-- ::: {.column width=.65} -->

```{r echo=FALSE, fig.width=3.8, fig.height=1.8, only.plot="1"}
.p.eq <- ggplot() + theme_void() + geom_text(aes(x=1,y=1,label="~"), size=10)
.p.data <- .matshow(A, .scale=FALSE, .lab = 0) + ggtitle("A")
.p.z <- .matshow(Z, .scale=FALSE, .lab = 0) + ggtitle("Z")
.p.zt <- .matshow(t(Z), .scale=FALSE, .lab = 0) + ggtitle("Z'")
.p.pr <- .matshow(Pr, .scale=TRUE, .lab = 0) + ggtitle("Θ")
.p0 <- ggplot() + theme_void()

wrap_plots(.p.data, .p0, .p.eq, .p0, .p.zt, .p0,
           wrap_plots(.p.pr, .p0, ncol=1, heights=c(1,9)),
           .p0,
           wrap_plots(.p.z, .p0, ncol=1, heights=c(1,9)),
           nrow = 1,
           widths=c(4, .01,.5,.05, .5, .05, .5, .05, 4))
```

```{r echo=FALSE, fig.width=3.8, fig.height=1.8, only.plot="2"}
oo <- order(apply(Z,2,which.max), decreasing=TRUE)

.p.eq <- ggplot() + theme_void() + geom_text(aes(x=1,y=1,label="~"), size=10)
.p.data <- .matshow(A[oo,oo], .scale=FALSE, .lab = 0) + ggtitle("A")
.p.z <- .matshow(Z[,oo], .scale=FALSE, .lab = 0) + ggtitle("Z")
.p.zt <- .matshow(t(Z[,oo]), .scale=FALSE, .lab = 0) + ggtitle("Z'")
.p.pr <- .matshow(Pr, .scale=TRUE, .lab = 0) + ggtitle("Θ")
.p0 <- ggplot() + theme_void()

wrap_plots(.p.data, .p0, .p.eq, .p0, .p.zt, .p0,
           wrap_plots(.p.pr, .p0, ncol=1, heights=c(1,9)),
           .p0,
           wrap_plots(.p.z, .p0, ncol=1, heights=c(1,9)),
           nrow = 1,
           widths=c(4, .01,.5,.05, .5, .05, .5, .05, 4))
```

<!-- ::: -->
<!-- ::: {.column width=.35} -->
<!-- EM algorithm (will be discussed in the later lectures) -->
<!-- $\prod_{k\ge k'}\prod_{i<j} \left( \theta_{kk'}^{A_{ij}} \left(1 - \theta_{kk'}\right)^{(1-A_{ij})} \right)^{Z_{ki}Z_{kj}}$ -->
<!-- ::: -->
<!-- :::::: -->


## A shared neighbourhood matrix (A friend of a friend $\approx$ a friend)

:::::: {.columns}
::: {.column width=.45}

* $S \gets A^{\top} A$

* $S_{ij} = \sum_{k} A_{ki} A_{kj}$, number of shared neighbours

* How many samples? Dimensionality?

* Can you see group structures?

:::
::: {.column width=.45}

```{r fig.width=2, fig.height=2}
.matshow(A %*% A, .scale=TRUE, .lab = 0)
```

:::
::::::


## Network is an (edge) incidence matrix (vertex x edge)


:::::: {.columns}
::: {.column width=.35}

* $M_{k,(i,j)} = 1$ if $A_{ik}=1$ and $A_{jk}=1$

```{r}
library(Matrix)
G <- karate;
.list <- ends(G, E(G));
m <- nrow(.list)
ii <- c(.list[,1],.list[,2])
jj <- rep(1:m,2)
xx <- rep(1,2*m)
M <- sparseMatrix(ii, jj, x=xx)
```

* How many samples? Dimensionality?

* Can you see group structures?

:::
::: {.column width=.64}

```{r echo=FALSE, fig.width=3.2, fig.height=1.5}
.matshow(M, .scale=FALSE, .lab = 0)
```

* How many non-zero elements for each column?

:::
::::::


## Enumerating shared neighbours for each edge

:::::: {.columns}
::: {.column width=.3}

* $M_{k,(i,j)} = A_{ki} A_{kj}$

```{r size="large"}
ee <- ends(G, E(G));
ii <- ee[,1]
jj <- ee[,2]
M2 <- A[,ii] * A[,jj]
```

* How many samples? Dimensionality?

* Can you see group structures?

:::
::: {.column width=.7}

```{r echo=FALSE, fig.width=3.2, fig.height=1.5}
.matshow(M2, .scale=FALSE, .lab = 0)
```

:::
::::::


## Another way to define the edge incidence matrix

:::::: {.columns}
::: {.column width=.35}

* $M_{k,(i,j)} = A_{ki} + A_{kj}$

```{r size="large"}
ee <- ends(G, E(G));
ii <- ee[,1]
jj <- ee[,2]
M3 <- A[,ii] + A[,jj]
```

* How many samples? Dimensionality?

* Can we try out clustering?

```{r size="large"}
.feat <- t(as.matrix(M3))
.out <-
  kmeans(.feat,
         centers=5,
         nstart=100)
```

:::
::: {.column width=.65}

An incidence feature matrix:

```{r echo=FALSE, fig.width=3.2, fig.height=1.5}
.matshow(M3, .scale=FALSE, .lab = 0) +
    ggtitle(str_c(nrow(M3), " x ", ncol(M3))) +
    theme(title = element_text(size=8))
```

_k_-means clustering can recover groups of edges

```{r echo=FALSE, fig.width=3.2, fig.height=.5}
## .pr <- .matshow(t(.out$centers), .lab=0, .scale=TRUE)
.pz <- .matshow(Matrix::sparseMatrix(i=.out$cluster,j=1:ncol(M3),x=rep(1,ncol(M3))), .scale=FALSE, .lab=0) + ggtitle(str_c(length(unique(.out$cluster)), " clusters x ", length(.out$cluster)," edges")) + theme(title = element_text(size=8))
print(.pz)
##wrap_plots(.pr, wrap_plots(.pz, ggplot() + theme_void(), heights=c(1,9)),
##widths=c(.5,9.5)) 
```

:::
::::::


## We may find overlapping membership by clustering the edges 

:::::: {.columns}
::: {.column width=.35}

* $M_{k,(i,j)} = A_{ki} + A_{kj}$

```{r echo = FALSE}
.dt <- apply.layout.dt(karate, "karate")
.dt[, k.edge := as.factor(.out$cluster)]
```

```{r echo = FALSE, fig.width=2, fig.height=2}
plot.layout.dt(.dt, .vsize=2, .esize=1, .add.lab=FALSE)
```

:::
::: {.column width=.65}

Sorted edges by the group membership:

```{r echo=FALSE, fig.width=3.2, fig.height=1.5}
.oo <- order(.out$cluster)
.matshow(M3[, .oo], .scale=FALSE, .lab = 0) +
    ggtitle(str_c(nrow(M3), " x ", ncol(M3)))
```

_k_-means clustering can recover groups of edges

```{r echo=FALSE, fig.width=3.2, fig.height=.5}
.pz <- .matshow(Matrix::sparseMatrix(i=.out$cluster[.oo],j=1:ncol(M3),x=rep(1,ncol(M3))), .scale=FALSE, .lab=0) + ggtitle(str_c(length(unique(.out$cluster)), " clusters x ", length(.out$cluster)," edges"))
print(.pz)
```

:::
::::::


## Summary 

* Gene set analysis (ignoring edges, only vertices)

* Diffusion-based network analysis (propagating info via edges)

* Stochastic block model to find sets in a network

