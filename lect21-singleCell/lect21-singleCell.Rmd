---
title: "Single-cell RNA-seq analysis"
author: |
    | Yongjin Park
    | University of British Columbia
date: "`r format(Sys.time(), '%d %B, %Y')`"
classoption: "aspectratio=169"
output:
    powerpoint_presentation:
        reference_doc: "_template.pptx"
    html_document:
        self_contained: true
    beamer_presentation:
        colortheme: "orchid"
        keep_tex: true
        latex_engine: xelatex
        slide_level: 2
header-includes:
  - \usepackage{cancel}
  - \usepackage{booktabs}
  - \usepackage{longtable}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage{wrapfig}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{pdflscape}
  - \usepackage{tabu}
  - \usepackage{threeparttable}
  - \usepackage{threeparttablex}
  - \usepackage[normalem]{ulem}
  - \usepackage{makecell}
  - \usepackage{xcolor}
  - \AtBeginSection[]{\begin{frame}\frametitle{Today's lecture}{\Large\tableofcontents[currentsection]}\end{frame}}
  - |
    \makeatletter
    \def\ps@titlepage{%
      \setbeamertemplate{footline}{}
    }
    \addtobeamertemplate{title page}{\thispagestyle{titlepage}}{}
    \makeatother
    \include{toc}
---


```{r setup, include=FALSE}
library(tidyverse)
library(data.table)
library(patchwork)
library(bigsnpr)
source("Util.R")
source("Setup.R")
fig.dir <- "Fig/singleCell/"
setup.env(fig.dir)
dir.create("Data", showWarnings=FALSE)
theme_set(theme_classic())
```

```{r}
if(!require(mmutilR)) remotes::install_github("causalpathlab/mmutilR")
```

# Technology



# Basic Data Q/C

## Single-cell RNA-seq data of human pancreatic cells


```{r}
raw.data <- fileset.list("Data/GSE85241")
.info <- rcpp_mmutil_info(raw.data$mtx)
cell.index <- rcpp_mmutil_read_index(raw.data$idx)
```


:::::: {.columns}
::: {.column width=.5}

\centerline{\includegraphics[height=.7\textheight]{Vis/Muraro_GSE85241.png}}

:::
::: {.column width=.5}

\large

We will use scRNA-seq data (GEO accession: GSE85241) as a working example.

* genes/features/rows: `r num.int(.info$max.row)`

* cells/columns: `r num.int(.info$max.col)`

* non-zero elements: `r num.int(.info$max.elem)`

:::
::::::

\tiny
Muraro \textit{et al.} \emph{Cell Systems} (2016)

```{r}
run.eda <- function(.data.file, .row.file=NULL, .col.file=NULL, out.file="out.RDS") {

    dir.create(dirname(out.file), recursive=TRUE, showWarnings=FALSE)

    if(file.exists(out.file)) return(readRDS(out.file))

    .scores <-
        rcpp_mmutil_compute_scores(.data.file,
                                   .row.file,
                                   .col.file)
    gene.scores <- setDT(.scores$row) # gene scores
    cell.scores <- setDT(.scores$col) # cell scores

    cell.pca <-
        rcpp_mmutil_pca(.data.file, RANK=50) %>%
        (function(x) x$V) %>%
        as.data.table %>%
        mutate(name = cell.scores$name)

    cell.tsne <- Rtsne::Rtsne(cell.pca, pca=FALSE,
                              check_duplicates=FALSE,
                              num_threads = 8) %>%
        (function(x) x$Y) %>%
        as.data.table %>%
        mutate(name = cell.scores$name)

    ret <- list(pca=cell.pca, tsne=cell.tsne, gene=gene.scores, cell=cell.scores)
    saveRDS(ret, out.file)
    return(ret)
}
```

```{r}
eda.out <- run.eda(raw.data$mtx, raw.data$row, raw.data$col,
                   str_c(fig.dir, "/raw_eda.RDS"))

cell.pca <- eda.out$pca
cell.tsne <- eda.out$tsne
gene.scores <- eda.out$gene
cell.scores <- eda.out$cell
```

## Statistics of genes across cells

```{r}
.fit.kmeans.log1p <- function(val, k, ...) {
    kmeans(log1p(as.matrix(val)), centers=k, nstart=100, ...)$cluster
}
.add.kmeans.log1p <- function(.dt, k, ...) {
    .mat <- as.matrix(.dt[, .(nnz, cv)])
    .dt %>%
        mutate(k := .fit.kmeans.log1p(.mat, k=k, ...)) %>%
        as.data.table
}

.file <- str_c(fig.dir, "data_stat.RDS")
if.needed(.file,
{
    .scores <- rcpp_mmutil_compute_scores(mtx_file = raw.data$mtx,
                                          row_file = raw.data$row,
                                          col_file = raw.data$col)
    .genes <- setDT(.scores$row) %>% .add.kmeans.log1p(k=7)
    saveRDS(.genes, file = .file)
})
.genes <- readRDS(.file)
```

```{r gene_qc, fig.width=5.8, fig.height=2.5}
.dt <- melt(.genes, id.vars = c("name", "k"))
.gg.plot(.dt, aes(x = log1p(value), y = ..count.., fill = variable)) +
    facet_wrap(~variable, scales="free", nrow=2) +
    geom_density(show.legend=FALSE) +
    scale_fill_brewer(palette = "Set3")
```

`nnz`: number of non-zero elements, `sd`: standard deviation, `cv`: coefficient of variation (`sd`/`mean`), `sum.sq`: sum of squares.

## Can we drop any features?


```{r gene_qc_by_nnz_cv, message=FALSE, fig.width=5, fig.height=2.5}
.dt <- melt(.genes[, .(name, nnz, cv, k)], id.vars=c("name","k"))
p1 <- .gg.plot(.dt, aes(x=log1p(value), fill=as.factor(k))) +
    facet_wrap(~variable, scales="free", ncol=1) +
    geom_histogram(colour="gray", size=.1, bins=50) +
    scale_fill_brewer("k-means", palette = "Set2")
p2 <- .gg.plot(.genes, aes(x=log1p(nnz), y=log1p(cv), fill=as.factor(k))) +
    geom_point(alpha=.5, pch=21, stroke=.1) +
    scale_fill_brewer("k-means", palette = "Set2", guide="none")
p1|p2
```

We don't like unstable genes with low average expressions and high CV.

```{r}
.clust.stat <- .genes[, .(`mean`=mean(`mean`), `cv`=mean(`cv`)), by = .(k)]
kk <- .clust.stat[`mean` > .1 & `cv` > 1, .(k)] %>% unlist
```

```{r}
.selected <-
    .genes[k %in% kk, .(name)] %>% 
    filter(!str_starts(name, "ERCC-")) %>%  # no spike-in controls
    unlist(use.names=FALSE)
.selected.hdr <- str_c(fig.dir, "/selected")
selected.data <- fileset.list(.selected.hdr)
if.needed(selected.data,
{
    selected.data <-
        rcpp_mmutil_copy_selected_rows(raw.data$mtx,
                                       raw.data$row,
                                       raw.data$col,
                                       .selected,
                                       .selected.hdr)
})

.file <- str_c(fig.dir, "selected_data_stat.RDS")
if.needed(.file,
{
    .scores <- rcpp_mmutil_compute_scores(selected.data$mtx,
                                          selected.data$row,
                                          selected.data$col)
    .genes <- setDT(.scores$row) %>% .add.kmeans.log1p(k=7)
    .cells <- setDT(.scores$col) %>% .add.kmeans.log1p(k=7)
    .genes[, c("gene", "chr") := tstrsplit(name, "__")]
    saveRDS(list(genes=.genes, cells=.cells), file = .file)
})
.stat <- readRDS(.file)
.genes <- .stat$genes
.cells <- .stat$cells
```


## Statistics of cells across genes

```{r cell_qc, fig.width=5.8, fig.height=2.5}
.dt <- melt(.cells, id.vars = c("name", "k"))
.gg.plot(.dt, aes(x = log1p(value))) +
    facet_wrap(~variable, scales="free", nrow=2) +
    geom_density(aes(y = ..count.., fill = variable), show.legend=FALSE) +
    scale_fill_brewer(palette = "Set3")
```

`nnz`: number of non-zero elements, `sd`: standard deviation, `cv`: coefficient of variation (`sd`/`mean`), `sum.sq`: sum of squares.


## Filter out cells that are not informative...?

```{r cell_qc_by_nnz_cv, message=FALSE, fig.width=5, fig.height=2.5}
.dt <- melt(.cells[, .(name, nnz, cv, k)], id.vars=c("name","k"))
p1 <- .gg.plot(.dt, aes(x=log1p(value), fill=as.factor(k))) +
    facet_wrap(~variable, scales="free", ncol=1) +
    geom_histogram(colour="gray", size=.1, bins=50) +
    scale_fill_brewer("k-means", palette = "Set2")
p2 <- .gg.plot(.cells, aes(x=log1p(nnz), y=log1p(cv), fill=as.factor(k))) +
    geom_point(alpha=.5, pch=21, stroke=.1) +
    geom_vline(xintercept = log1p(1000), color="red", size=1) +
    scale_fill_brewer("k-means", palette = "Set2", guide="none")

p1|p2
```

We may remove cells with too few non-zero elements (e.g., NNZ $<$ 1000).

## Exploratory Data Analysis with tSNE

:::::: {.columns}
::: {.column width=.5}

```{r fig.width=3, fig.height=2.5, echo = FALSE, onslide.plot="1-"}
.gg.plot(cell.tsne, aes(V1, V2)) + geom_point(stroke=0, size=.7) + xlab("tSNE1") + ylab("tSNE2")
```

:::
::: {.column width=.5}

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=2}
.dt <- left_join(cell.tsne, cell.scores)
.gg.plot(.dt, aes(V1, V2, fill=nnz)) +
    theme(legend.position=c(1,1), legend.justification=c(1,1)) +
    theme(legend.key.width=unit(.1,"lines")) +
    theme(legend.key.height=unit(.5,"lines")) +
    theme(legend.text = element_text(size=6)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller(palette = "RdPu", direction=1) +
    ggtitle("non-zero elements") +
    xlab("tSNE1") +
    ylab("tSNE2")
```

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=3}
.dt <- left_join(cell.tsne, cell.scores)
.gg.plot(.dt, aes(V1, V2, fill=log(1+`sd`))) +
    theme(legend.position=c(1,1), legend.justification=c(1,1)) +
    theme(legend.key.width=unit(.1,"lines")) +
    theme(legend.key.height=unit(.5,"lines")) +
    theme(legend.text = element_text(size=6)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller("sd", palette = "RdPu", direction=1, labels=function(x) round(exp(x)-1)) +
    ggtitle("standard deviation") +
    xlab("tSNE1") +
    ylab("tSNE2")
```

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=4}
.dt <-
    left_join(cell.tsne, cell.scores) %>%
    filter(nnz >= 1000)

.gg.plot(.dt, aes(V1, V2, fill=log(1+`sd`))) +
    theme(legend.position=c(1,1), legend.justification=c(1,1)) +
    theme(legend.key.width=unit(.1,"lines")) +
    theme(legend.key.height=unit(.5,"lines")) +
    theme(legend.text = element_text(size=6)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller("sd", palette = "RdPu", direction=1, labels=function(x) round(exp(x)-1)) +
    ggtitle("after filter out NNZ < 1000") +
    xlab("tSNE1") +
    ylab("tSNE2")
```

```{r include = FALSE}
.qc.hdr <- str_c(fig.dir, "/qc_data")
qc.data <- fileset.list(.qc.hdr)

if.needed(qc.data, 
{
    qc.data <-
        rcpp_mmutil_copy_selected_columns(raw.data$mtx,
                                          raw.data$row,
                                          raw.data$col,
                                          .dt$name,
                                          .qc.hdr)
})
```

:::
::::::


# Data normalization

## 


# Latent topic modelling


## Embedded Topic Model



# Doublet detection in single-cell data

## What is a doublet in single-cell data?

**Biological/technical definition:**

- One or more cells captured (usually at most two cells by chance)

- Thus, multiple cells accidental share the same cell barcode sequence

- Not so clear in general... since we missed the chance to assign
  different tags to different cells encapsulated in the same droplet.

**Statistical definition**:

- If we could find marker genes of multiple cell types are
  simultaneously expressed...

- An unvetted approach: Find ambiguous/intermediate coordinates in
  PCA/tSNE/UMAP (after removing ambient cells).


## Can we create artificial doublets?

\large

A straightforward definition (used in [`DoubletFinder`](https://github.com/chris-mcginnis-ucsf/DoubletFinder)):

For each cell $i$:

* Take some other $j$ by random selection

* Create an artificial doublet

$$\tilde{\mathbf{x}} \gets \frac{1}{2}(\mathbf{x}_{i} + \mathbf{x}_{j})$$


Some thought questions:

* Doublets within the same cell type?

* Doublets between the different cell types?


```{r echo = FALSE}
doublet.hdr <- str_c(fig.dir, "/qc_doublet")
doublet.data <- fileset.list(doublet.hdr)

.readv <- function(...) {
    fread(..., header=FALSE) %>%
        unlist(use.names = FALSE)
}

.writev <- function(v, ...) {
    as.data.table(v) %>%
        fwrite(..., col.names=FALSE, row.names=FALSE)
}
```

```{r}
if.needed(doublet.data,
{
  .rows <- .readv(qc.data$row)
  .cols <- .readv(qc.data$col)
  .rnd <- sample(length(.cols))

  ## doublet mixology
  X <- read.sparse(qc.data$mtx)
  X.rnd <- read.sparse(qc.data$mtx, .rnd)
  X.dbl <- round((X + X.rnd)/2)

  ## give distinctive names
  .dbl <- str_c(.cols,.cols[.rnd],sep="+")
  .writev(c(.cols, .dbl),file=doublet.data$col)
  .writev(.rows, file=doublet.data$row)

  rcpp_mmutil_write_mtx(cbind(X, X.dbl),
              doublet.data$mtx)
})
```

```{r echo=FALSE}
dbl.eda <- run.eda(doublet.data$mtx,
                   doublet.data$row,
                   doublet.data$col,
                   str_c(fig.dir, "/dbl_eda.RDS"))
```

## Can you tell the difference by a quick visual inspection?


```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=1}
.dt <- copy(dbl.eda$pca)
.dt[, dbl := "singlet"]
.dt[str_detect(`name`, "[+]+"), dbl := "doublet"]

.gg.plot(.dt, aes(V1, V2, fill=dbl)) +
    geom_point(stroke=.1, size=1, pch=21, alpha=.5) +
    scale_fill_brewer("", palette = "Set1") +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.title = element_blank()) +
    theme(legend.key.width = unit(.1,"lines")) +
    theme(legend.key.height = unit(.2,"lines")) +
    xlab("PC1") + ylab("PC2")
```

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=2}
.dt <- copy(dbl.eda$tsne)
.dt[, dbl := "singlet"]
.dt[str_detect(`name`, "[+]+"), dbl := "doublet"]

.gg.plot(.dt, aes(V1, V2, fill=dbl)) +
    geom_point(stroke=.1, size=1, pch=21, alpha=.5) +
    scale_fill_brewer("", palette = "Set1") +
    theme(legend.position = c(0,0)) +
    theme(legend.justification = c(0,0)) +
    theme(legend.title = element_blank()) +
    theme(legend.key.width = unit(.1,"lines")) +
    theme(legend.key.height = unit(.2,"lines")) +
    xlab("tSNE1") + ylab("tSNE2")
```

```{r fig.width=5, fig.height=2.8, echo = FALSE, only.plot=3}
.gg.plot(.dt, aes(V1, V2, fill=dbl)) +
    facet_grid(.~dbl) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_brewer(palette = "Set1") +
    theme(legend.position = "none") +
    xlab("tSNE1") + ylab("tSNE2")
```

##

\Large

> Can we design a classifier to distinguish singlets vs. doublets?


## k-Nearest Neighbour classification for doublet detection

\large

* Step 1. Create artificial doublets, $\tilde{\mathbf{x}}$

* Step 2. Mix them with the original cells and perform PCA

* Step 3. Find nearest neighbours of the original cells (using \#PC=50)

* Step 4. Count the number of doublets in the neighbourhood

```{r}
.knn.file <- str_c(fig.dir, "/doublet_knn.RDS")
if.needed(.knn.file,
{
  .out <-
    rcpp_mmutil_match_files(raw.data$mtx,
                            doublet.data$mtx,
                            knn = 50,
                            RANK = 50,
                            NUM_THREADS = 15)
  knn.dt <- setDT(.out)
  saveRDS(knn.dt, .knn.file)
})
```

## k-Nearest Neighbour classification for doublet detection

:::::: {.columns}
::: {.column width=.48}

* **Q: How many of my neighbours are indeed a doublet?**

```{r}
.src.cells <-
  fread(raw.data$col, col.names="cell", header=FALSE) %>%
  mutate(src.index = 1:n()) %>%
  as.data.table

.tgt.cells <-
  fread(doublet.data$col, col.names="cell", header=FALSE) %>%
  mutate(doublet = str_detect(cell, "[+]")) %>% 
  mutate(tgt.index = 1:n()) %>% as.data.table

knn.dt <- readRDS(.knn.file) %>%
  merge(.src.cells) %>% 
  merge(.tgt.cells, by="tgt.index", suffixes = c(".src", ".tgt")) %>% 
  select(cell.src, cell.tgt, dist, doublet) %>%
  as.data.table()
```

$$\hat{P}_{i} = \frac{1}{|\mathcal{N}(i)|}\sum_{j \in \mathcal{N}(i)} I\{j\textsf{ is a doublet}\}$$

```{r}
.dbl.dt <-
  knn.dt[,
         .(`P`=mean(doublet)),
         by = .(cell.src)]
```

**Key assumption**:
There is a principal component that can set apart hidden doublets from the most of singlets.

:::
::: {.column width=.48}

```{r echo=FALSE, fig.width=2.5, fig.height=2, only.plot=1}
.dt <- .dbl.dt %>%
  arrange(`P`) %>%
  mutate(i = 1:n())

.gg.plot(.dt, aes(i, `P`)) +
    ylab("Probabiliy of doublet") +
    xlab("cells sorted") +
    theme(axis.ticks.x = element_blank()) +
    theme(axis.text.x = element_blank()) +
    geom_point(stroke=0)
```

```{r echo=FALSE, fig.width=2.5, fig.height=2.2, only.plot=2}
.dt <- eda.out$tsne %>%
    merge(eda.out$cell) %>% 
    merge(.dbl.dt, by.x="name", by.y="cell.src") %>%
    na.omit

.gg.plot(.dt, aes(V1, V2, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("tSNE1") + ylab("tSNE2")
```

```{r echo=FALSE, fig.width=2.5, fig.height=2, only.plot=3}
.dt <- eda.out$pca %>%
    merge(eda.out$cell) %>% 
    merge(.dbl.dt, by.x="name", by.y="cell.src") %>%
    na.omit

.gg.plot(.dt, aes(V1, V2, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(0,0)) +
    theme(legend.justification = c(0,0)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("PC1") + ylab("PC2")
```

```{r echo=FALSE, fig.width=2.5, fig.height=2, only.plot=4}
.gg.plot(.dt, aes(V3, V4, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(0,0)) +
    theme(legend.justification = c(0,0)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("PC3") + ylab("PC4")
```

```{r echo=FALSE, fig.width=2.5, fig.height=2, only.plot=5}
.gg.plot(.dt, aes(V5, V6, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("PC5") + ylab("PC6")
```
:::
::::::

