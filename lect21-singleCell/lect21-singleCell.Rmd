---
title: "Single-cell RNA-seq analysis"
author: |
    | Yongjin Park
    | University of British Columbia
date: "`r format(Sys.time(), '%d %B, %Y')`"
classoption: "aspectratio=169"
output:
    powerpoint_presentation:
        reference_doc: "_template.pptx"
    html_document:
        self_contained: true
    beamer_presentation:
        colortheme: "orchid"
        keep_tex: true
        latex_engine: xelatex
        slide_level: 2
header-includes:
  - \usepackage{cancel}
  - \usepackage{booktabs}
  - \usepackage{longtable}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage{wrapfig}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{pdflscape}
  - \usepackage{tabu}
  - \usepackage{threeparttable}
  - \usepackage{threeparttablex}
  - \usepackage[normalem]{ulem}
  - \usepackage{makecell}
  - \usepackage{xcolor}
  - \AtBeginSection[]{\begin{frame}\frametitle{Today's lecture}{\Large\tableofcontents[currentsection]}\end{frame}}
  - |
    \makeatletter
    \def\ps@titlepage{%
      \setbeamertemplate{footline}{}
    }
    \addtobeamertemplate{title page}{\thispagestyle{titlepage}}{}
    \makeatother
    \include{toc}
---


```{r setup, include=FALSE}
library(tidyverse)
library(data.table)
library(patchwork)
library(bigsnpr)
source("Util.R")
source("Setup.R")
fig.dir <- "Fig/singleCell/"
setup.env(fig.dir)
dir.create("Data", showWarnings=FALSE)
theme_set(theme_classic())
if(!require(mmutilR)) remotes::install_github("causalpathlab/mmutilR")
```

# Single-cell sequencing technology

## Droplet-based single-cell sequencing technology

\vfill
\centerline{\includegraphics[width=\textwidth]{Vis/dropseq_technology/dropseq1.pdf}}
\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)

## Drop-seq idea 1: Capture one cell with a microbead in a droplet

\vfill
\centerline{\includegraphics[height=.7\textheight]{Vis/dropseq_technology/dropseq2.pdf}}
\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)

## Drop-seq idea 2: Massively-parallel sequencing followed by cell-specific barcoding

\vfill
\centerline{\includegraphics[width=\textwidth]{Vis/dropseq_technology/dropseq3.pdf}}
\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)


## Drop-seq idea 3: How single-cell barcodes distinguish transcripts from different cells

\vfill
\centerline{\includegraphics[width=\textwidth]{Vis/dropseq_technology/dropseq4.pdf}}
\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)


## How do we construct millions of unique barcodes?

\vfill

\only<1>{
\includegraphics[height=.5\textheight]{Vis/dropseq_technology/dropseq5.pdf}
}

\only<2>{
\includegraphics[height=.5\textheight]{Vis/dropseq_technology/dropseq6.pdf}
}

\only<3>{
\includegraphics[height=.55\textheight]{Vis/dropseq_technology/dropseq7.pdf}
}

\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)

## The lengths of barcode sequences determine data dimensionality

\vfill


:::::: {.columns}
::: {.column width=.75}

\centerline{\includegraphics[width=\linewidth]{Vis/dropseq_technology/dropseq8.pdf}}

:::
::: {.column width=.2}

\begin{block}{}
Technically, we can build up to a `r num.int(4^8)` $\times$ `r num.int(4^12)`, gene $\times$ cell expression matrix in one single-cell RNA-seq experiment.
\end{block}

:::
::::::

\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)


## Droplet-based single-cell sequencing pipeline

\vfill
\centerline{\includegraphics[width=.9\textwidth]{Vis/dropseq_technology/dropseq9.pdf}}
\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)

## People love to see this high-dimensional data matrix in 2D/3D space

\vfill

:::::: {.columns}
::: {.column width=.45}

\onslide<1->{
\includegraphics[width=.9\linewidth]{Vis/scRNA_data_cartoon.pdf}
}

:::
::: {.column width=.45}

\onslide<2->{
\includegraphics[width=.8\linewidth]{Vis/scRNA_data_cartoon_tSNE.pdf}
}

:::
::::::

\vfill


\onslide<2->{
\small
\texttt{tSNE}: t-distributed Stochastic Neighbourhood Embedding (Van der Maaten \& Hinton, 2008).
}
\onslide<3>{
\normalsize
Is that it? \textbf{\color{teal} No, statisticians do much more than visualization!}
}

# Basic Data Q/C

## Single-cell RNA-seq data of human pancreatic cells

```{r}
raw.data <- fileset.list("Data/GSE85241")
.info <- rcpp_mmutil_info(raw.data$mtx)
cell.index <- rcpp_mmutil_read_index(raw.data$idx)
```


:::::: {.columns}
::: {.column width=.45}

\centerline{\includegraphics[height=.7\textheight]{Vis/Muraro_GSE85241.png}}

:::
::: {.column width=.45}

$${}$$

\large

We will use scRNA-seq data (GEO accession: GSE85241) as a working example.

$${}$$

* genes/features/rows: `r num.int(.info$max.row)`

* cells/columns: `r num.int(.info$max.col)`

* non-zero elements: `r num.int(.info$max.elem)`

* ~ `r round(100 * .info$max.elem / .info$max.col / .info$max.row)` % non-zero

:::
::::::

\tiny
Muraro \textit{et al.} \emph{Cell Systems} (2016)

```{r}
run.eda <- function(.data.file, .row.file=NULL, .col.file=NULL, out.file="out.RDS") {

    dir.create(dirname(out.file), recursive=TRUE, showWarnings=FALSE)

    if(file.exists(out.file)) return(readRDS(out.file))

    .scores <-
        rcpp_mmutil_compute_scores(.data.file,
                                   .row.file,
                                   .col.file)
    gene.scores <- setDT(.scores$row) # gene scores
    cell.scores <- setDT(.scores$col) # cell scores

    cell.pca <-
        rcpp_mmutil_pca(.data.file, RANK=50) %>%
        (function(x) x$V) %>%
        as.data.table %>%
        mutate(name = cell.scores$name)

    cell.tsne <- Rtsne::Rtsne(cell.pca, pca=FALSE,
                              check_duplicates=FALSE,
                              num_threads = 8) %>%
        (function(x) x$Y) %>%
        as.data.table %>%
        mutate(name = cell.scores$name)

    ret <- list(pca=cell.pca, tsne=cell.tsne, gene=gene.scores, cell=cell.scores)
    saveRDS(ret, out.file)
    return(ret)
}
```

```{r}
eda.out <- run.eda(raw.data$mtx, raw.data$row, raw.data$col,
                   str_c(fig.dir, "/raw_eda.RDS"))

cell.pca <- eda.out$pca
cell.tsne <- eda.out$tsne
gene.scores <- eda.out$gene
cell.scores <- eda.out$cell
```

## Gene-level statistics across cells

```{r}
.fit.kmeans.log1p <- function(val, k, ...) {
    kmeans(log1p(as.matrix(val)), centers=k, nstart=100, ...)$cluster
}
.add.kmeans.log1p <- function(.dt, k, ...) {
    .mat <- as.matrix(.dt[, .(nnz, cv)])
    .dt %>%
        mutate(k := .fit.kmeans.log1p(.mat, k=k, ...)) %>%
        as.data.table
}

.file <- str_c(fig.dir, "data_stat.RDS")
if.needed(.file,
{
    .scores <- rcpp_mmutil_compute_scores(mtx_file = raw.data$mtx,
                                          row_file = raw.data$row,
                                          col_file = raw.data$col)
    .genes <- setDT(.scores$row) %>% .add.kmeans.log1p(k=7)
    saveRDS(.genes, file = .file)
})
.genes <- readRDS(.file)
```

```{r gene_qc, fig.width=5.8, fig.height=2.5}
.dt <- melt(.genes, id.vars = c("name", "k"))
.gg.plot(.dt, aes(x = log1p(value), y = ..count.., fill = variable)) +
    facet_wrap(~variable, scales="free", nrow=2) +
    geom_density(show.legend=FALSE) +
    scale_fill_brewer(palette = "Set3")
```

`nnz`: number of non-zero elements, `sd`: standard deviation, `cv`: coefficient of variation (`sd`/`mean`), `sum.sq`: sum of squares.

## Can we drop any genes?

```{r gene_qc_by_nnz_cv, message=FALSE, fig.width=5, fig.height=2.5}
.dt <- melt(.genes[, .(name, nnz, cv, k)], id.vars=c("name","k"))
p1 <- .gg.plot(.dt, aes(x=log1p(value), fill=as.factor(k))) +
    facet_wrap(~variable, scales="free", ncol=1) +
    geom_histogram(colour="gray", size=.1, bins=50) +
    scale_fill_brewer("k-means", palette = "Set2")
p2 <- .gg.plot(.genes, aes(x=log1p(nnz), y=log1p(cv), fill=as.factor(k))) +
    geom_point(alpha=.5, pch=21, stroke=.1) +
    scale_fill_brewer("k-means", palette = "Set2", guide="none")
p1|p2
```

We don't like unstable genes with low average expressions and high CV.

```{r}
.clust.stat <- .genes[, .(`mean`=mean(`mean`), `cv`=mean(`cv`)), by = .(k)]
kk <- .clust.stat[`mean` > .1 & `cv` > 1, .(k)] %>% unlist
```

```{r}
.selected <-
    .genes[k %in% kk, .(name)] %>%
    filter(!str_starts(name, "ERCC-")) %>%  # no spike-in controls
    unlist(use.names=FALSE)
.selected.hdr <- str_c(fig.dir, "/selected")
selected.data <- fileset.list(.selected.hdr)
if.needed(selected.data,
{
    selected.data <-
        rcpp_mmutil_copy_selected_rows(raw.data$mtx,
                                       raw.data$row,
                                       raw.data$col,
                                       .selected,
                                       .selected.hdr)
})

.file <- str_c(fig.dir, "selected_data_stat.RDS")
if.needed(.file,
{
    .scores <- rcpp_mmutil_compute_scores(selected.data$mtx,
                                          selected.data$row,
                                          selected.data$col)
    .genes <- setDT(.scores$row) %>% .add.kmeans.log1p(k=7)
    .cells <- setDT(.scores$col) %>% .add.kmeans.log1p(k=7)
    .genes[, c("gene", "chr") := tstrsplit(name, "__")]
    saveRDS(list(genes=.genes, cells=.cells), file = .file)
})
.stat <- readRDS(.file)
.genes <- .stat$genes
.cells <- .stat$cells
```


## Cell-level statistics across genes within each cell

```{r cell_qc, fig.width=5.8, fig.height=2.5}
.dt <- melt(.cells, id.vars = c("name", "k"))
.gg.plot(.dt, aes(x = log1p(value))) +
    facet_wrap(~variable, scales="free", nrow=2) +
    geom_density(aes(y = ..count.., fill = variable), show.legend=FALSE) +
    scale_fill_brewer(palette = "Set3")
```

`nnz`: number of non-zero elements, `sd`: standard deviation, `cv`: coefficient of variation (`sd`/`mean`), `sum.sq`: sum of squares.


## Filter out cells that are not informative...?

```{r cell_qc_by_nnz_cv, message=FALSE, fig.width=5, fig.height=2.5}
.dt <- melt(.cells[, .(name, nnz, cv, k)], id.vars=c("name","k"))
p1 <- .gg.plot(.dt, aes(x=log1p(value), fill=as.factor(k))) +
    facet_wrap(~variable, scales="free", ncol=1) +
    geom_histogram(colour="gray", size=.1, bins=50) +
    scale_fill_brewer("k-means", palette = "Set2")
p2 <- .gg.plot(.cells, aes(x=log1p(nnz), y=log1p(cv), fill=as.factor(k))) +
    geom_point(alpha=.5, pch=21, stroke=.1) +
    geom_vline(xintercept = log1p(1000), color="red", size=1) +
    scale_fill_brewer("k-means", palette = "Set2", guide="none")

p1|p2
```

We may remove cells with too few non-zero elements (e.g., NNZ $<$ 1000).

## Exploratory Data Analysis with tSNE

:::::: {.columns}
::: {.column width=.5}

```{r fig.width=3, fig.height=2.5, echo = FALSE, onslide.plot="1-"}
.gg.plot(cell.tsne, aes(V1, V2)) + geom_point(stroke=0, size=.7) + xlab("tSNE1") + ylab("tSNE2")
```

:::
::: {.column width=.5}

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=2}
.dt <- left_join(cell.tsne, cell.scores)
.gg.plot(.dt, aes(V1, V2, fill=nnz)) +
    theme(legend.position=c(1,1), legend.justification=c(1,1)) +
    theme(legend.key.width=unit(.1,"lines")) +
    theme(legend.key.height=unit(.5,"lines")) +
    theme(legend.text = element_text(size=6)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller(palette = "RdPu", direction=1) +
    ggtitle("non-zero elements") +
    xlab("tSNE1") +
    ylab("tSNE2")
```

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=3}
.dt <- left_join(cell.tsne, cell.scores)
.gg.plot(.dt, aes(V1, V2, fill=log(1+`sd`))) +
    theme(legend.position=c(1,1), legend.justification=c(1,1)) +
    theme(legend.key.width=unit(.1,"lines")) +
    theme(legend.key.height=unit(.5,"lines")) +
    theme(legend.text = element_text(size=6)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller("sd", palette = "RdPu", direction=1, labels=function(x) round(exp(x)-1)) +
    ggtitle("standard deviation") +
    xlab("tSNE1") +
    ylab("tSNE2")
```

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=4}
.dt <-
    left_join(cell.tsne, cell.scores) %>%
    filter(nnz >= 1000)

.gg.plot(.dt, aes(V1, V2, fill=log(1+`sd`))) +
    theme(legend.position=c(1,1), legend.justification=c(1,1)) +
    theme(legend.key.width=unit(.1,"lines")) +
    theme(legend.key.height=unit(.5,"lines")) +
    theme(legend.text = element_text(size=6)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller("sd", palette = "RdPu", direction=1, labels=function(x) round(exp(x)-1)) +
    ggtitle("after filter out NNZ < 1000") +
    xlab("tSNE1") +
    ylab("tSNE2")
```

```{r include = FALSE}
.qc.hdr <- str_c(fig.dir, "/qc_data")
qc.data <- fileset.list(.qc.hdr)

if.needed(qc.data,
{
    qc.data <-
        rcpp_mmutil_copy_selected_columns(raw.data$mtx,
                                          raw.data$row,
                                          raw.data$col,
                                          .dt$name,
                                          .qc.hdr)
})
```

:::
::::::


# Data normalization across many batches

##

```{r}
if.needed("Data/GSE131886_RAW.tar",
{
    options(timeout=1000)
    .url <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE131886&format=file"
    download.file(.url, "Data/GSE131886_RAW.tar")
})

dir.create("Data/GSE131886/", recursive = TRUE, showWarnings = FALSE)
.hdrs <- "Data/GSE131886/" %&%
    c("GSM3823985_HPD1_filtered_matrix",
      "GSM3823986_HPD2_filtered_matrix",
      "GSM3823987_HPD3_filtered_matrix")

.mtx.files <- lapply(.hdrs, function(x) x %&% ".mtx.gz")

if.needed(.mtx.files,
{
    untar("Data/GSE131886_RAW.tar", exdir="Data/GSE131886")
})
```


```{r}

mmutilR::rcpp_mmutil_merge_file_sets


features <- 

fread("Data/GSE131886/GSM3823986_HPD2_filtered_features.tsv.gz", header=FALSE)

fread("Data/GSE131886/GSM3823986_HPD2_filtered_barcodes.tsv.gz", header=FALSE)

```


# Latent topic modelling


## Embedded Topic Model



# Doublet detection in single-cell data

## scRNA-seq pipeline: What if we capture more than one cell in a droplet?

\vfill
\centerline{\includegraphics[width=.9\textwidth]{Vis/dropseq_technology/dropseq9.pdf}}
\vfill
\tiny
Macosko \textit{et al.}, \emph{Cell} (2015)

## What is a doublet in single-cell data?

**Biological/technical definition:**

- One or more cells captured (usually at most two cells by chance)

- Thus, multiple cells accidental share the same cell barcode sequence

- Not so clear in general... since we missed the chance to assign
  different tags to different cells encapsulated in the same droplet.

**Statistical definition**:

- If we could find marker genes of multiple cell types are
  simultaneously expressed...

- An unvetted approach: Find ambiguous/intermediate coordinates in
  PCA/tSNE/UMAP (after removing ambient cells).


## Can we create artificial doublets?

\large

A straightforward definition (used in [`DoubletFinder`](https://github.com/chris-mcginnis-ucsf/DoubletFinder)):

For each cell $i$:

* Take some other $j$ by random selection

* Create an artificial doublet

$$\tilde{\mathbf{x}} \gets \frac{1}{2}(\mathbf{x}_{i} + \mathbf{x}_{j})$$


Some thought questions:

* Doublets within the same cell type?

* Doublets between the different cell types?


```{r echo = FALSE}
doublet.hdr <- str_c(fig.dir, "/qc_doublet")
doublet.data <- fileset.list(doublet.hdr)

.readv <- function(...) {
    fread(..., header=FALSE) %>%
        unlist(use.names = FALSE)
}

.writev <- function(v, ...) {
    as.data.table(v) %>%
        fwrite(..., col.names=FALSE, row.names=FALSE)
}
```

```{r}
if.needed(doublet.data,
{
  .rows <- .readv(qc.data$row)
  .cols <- .readv(qc.data$col)
  .rnd <- sample(length(.cols))

  ## doublet mixology
  X <- read.sparse(qc.data$mtx)
  X.rnd <- read.sparse(qc.data$mtx, .rnd)
  X.dbl <- round((X + X.rnd)/2)

  ## give distinctive names
  .dbl <- str_c(.cols,.cols[.rnd],sep="+")
  .writev(c(.cols, .dbl),file=doublet.data$col)
  .writev(.rows, file=doublet.data$row)

  rcpp_mmutil_write_mtx(cbind(X, X.dbl),
              doublet.data$mtx)
})
```

```{r echo=FALSE}
dbl.eda <- run.eda(doublet.data$mtx,
                   doublet.data$row,
                   doublet.data$col,
                   str_c(fig.dir, "/dbl_eda.RDS"))
```

## k-Nearest Neighbour classification for doublet detection

\vfill

\centerline{\includegraphics[width=.9\textwidth]{Vis/doublet_knn.pdf}}

\vfill
\tiny

## Can you tell the difference by a quick visual inspection?

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=1}
.dt <- copy(dbl.eda$pca)
.dt[, dbl := "singlet"]
.dt[str_detect(`name`, "[+]+"), dbl := "doublet"]

.gg.plot(.dt, aes(V1, V2, fill=dbl)) +
    geom_point(stroke=.1, size=1, pch=21, alpha=.5) +
    scale_fill_brewer("", palette = "Set1") +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.title = element_blank()) +
    theme(legend.key.width = unit(.1,"lines")) +
    theme(legend.key.height = unit(.2,"lines")) +
    xlab("PC1") + ylab("PC2")
```

```{r fig.width=3, fig.height=2.5, echo = FALSE, only.plot=2}
.dt <- copy(dbl.eda$tsne)
.dt[, dbl := "singlet"]
.dt[str_detect(`name`, "[+]+"), dbl := "doublet"]

.gg.plot(.dt, aes(V1, V2, fill=dbl)) +
    geom_point(stroke=.1, size=1, pch=21, alpha=.5) +
    scale_fill_brewer("", palette = "Set1") +
    theme(legend.position = c(0,0)) +
    theme(legend.justification = c(0,0)) +
    theme(legend.title = element_blank()) +
    theme(legend.key.width = unit(.1,"lines")) +
    theme(legend.key.height = unit(.2,"lines")) +
    xlab("tSNE1") + ylab("tSNE2")
```

```{r fig.width=5, fig.height=2.8, echo = FALSE, only.plot=3}
.gg.plot(.dt, aes(V1, V2, fill=dbl)) +
    facet_grid(.~dbl) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_brewer(palette = "Set1") +
    theme(legend.position = "none") +
    xlab("tSNE1") + ylab("tSNE2")
```

##

\Large

> Can we design a classifier to distinguish singlets vs. doublets?

## k-Nearest Neighbour classification for doublet detection

\large

* Step 1. Create artificial doublets, $\tilde{\mathbf{x}}$

* Step 2. Mix them with the original cells and perform PCA

* Step 3. Find nearest neighbours of the original cells (using \#PC=50)

* Step 4. Count the number of doublets in the neighbourhood

```{r}
.knn.file <- str_c(fig.dir, "/doublet_knn.RDS")
if.needed(.knn.file,
{
  .out <-
    rcpp_mmutil_match_files(raw.data$mtx,
                            doublet.data$mtx,
                            knn = 50,
                            RANK = 50,
                            NUM_THREADS = 15)
  knn.dt <- setDT(.out)
  saveRDS(knn.dt, .knn.file)
})
```

## k-Nearest Neighbour classification for doublet detection

:::::: {.columns}
::: {.column width=.48}

* **Q: How many of my neighbours are indeed a doublet?**

```{r}
.src.cells <-
  fread(raw.data$col, col.names="cell", header=FALSE) %>%
  mutate(src.index = 1:n()) %>%
  as.data.table

.tgt.cells <-
  fread(doublet.data$col, col.names="cell", header=FALSE) %>%
  mutate(doublet = str_detect(cell, "[+]")) %>%
  mutate(tgt.index = 1:n()) %>% as.data.table

knn.dt <- readRDS(.knn.file) %>%
  merge(.src.cells) %>%
  merge(.tgt.cells, by="tgt.index", suffixes = c(".src", ".tgt")) %>%
  select(cell.src, cell.tgt, dist, doublet) %>%
  as.data.table()
```

$$\hat{P}_{i} = \frac{1}{|\mathcal{N}(i)|}\sum_{j \in \mathcal{N}(i)} I\{j\textsf{ is a doublet}\}$$

```{r}
.dbl.dt <-
  knn.dt[,
         .(`P`=mean(doublet)),
         by = .(cell.src)]
```

**Key assumption**:
There is a principal component that can set apart hidden doublets from the most of singlets.

:::
::: {.column width=.48}

```{r fig.width=2.5, fig.height=2, only.plot=1}
.dt <- .dbl.dt %>%
  arrange(`P`) %>%
  mutate(i = 1:n())

.gg.plot(.dt, aes(i, `P`)) +
    ylab("Probabiliy of doublet") +
    xlab("cells sorted") +
    theme(axis.ticks.x = element_blank()) +
    theme(axis.text.x = element_blank()) +
    geom_point(stroke=0)
```

```{r fig.width=2.5, fig.height=2.2, only.plot=2}
.dt <- eda.out$tsne %>%
    merge(eda.out$cell) %>%
    merge(.dbl.dt, by.x="name", by.y="cell.src") %>%
    na.omit

.gg.plot(.dt, aes(V1, V2, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("tSNE1") + ylab("tSNE2")
```

```{r fig.width=2.5, fig.height=2, only.plot=3}
.dt <- eda.out$pca %>%
    merge(eda.out$cell) %>%
    merge(.dbl.dt, by.x="name", by.y="cell.src") %>%
    na.omit

.gg.plot(.dt, aes(V1, V2, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(0,0)) +
    theme(legend.justification = c(0,0)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("PC1") + ylab("PC2")
```

```{r fig.width=2.5, fig.height=2, only.plot=4}
.gg.plot(.dt, aes(V3, V4, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(0,1)) +
    theme(legend.justification = c(0,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("PC3") + ylab("PC4")
```

```{r fig.width=2.5, fig.height=2, only.plot=5}
.gg.plot(.dt, aes(V5, V6, fill=`P`)) +
    geom_point(size=1, stroke=.1, pch=21) +
    scale_fill_distiller("P", palette="YlGnBu",direction=1) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("PC5") + ylab("PC6")
```
:::
::::::

## Artificial Neural Network-based classification for doublet detection

\vfill

\centerline{\includegraphics[width=.9\textwidth]{Vis/doublet_ann.pdf}}

\vfill

## Training a parametric classifier to discern doublets vs. singlets

```{r echo = FALSE}
library(torch)
torch_set_num_threads(8)
```

:::::: {.columns}
::: {.column width=.45}

\large

$$f: \mathbf{x}_{i} \to y_{i},\, y \in \{ 0, 1 \}$$

```{r echo=TRUE, size="tiny"}
build.classifier <-
    nn_module(
        classname = "classfier",
        initialize = function(d, k = 5) {
            self$fc <- nn_sequential(
                nn_batch_norm1d(d),
                nn_linear(d, k),
                nn_batch_norm1d(k),
                nn_relu(),
                nn_linear(k, 2 * k),
                nn_batch_norm1d(2 * k),
                nn_relu(),
                nn_linear(2 * k, 1),
                nn_sigmoid())
        },
        forward = function(x, min_=.01, max_=.99) {
            torch_clamp(self$fc(x), min_, max_)
        })
```

:::
::: {.column width=.5}

$$\prod_{i=1}^{n} f(\mathbf{x}_{i})^{y_{i}} (1 - f(\mathbf{x}_{i}))^{1 - y_{i}}$$

```{r echo = FALSE}
llik <- function(y.hat, y) {
    torch_sum(
        y * torch_log(y.hat) +
        (-y + 1) * torch_log1p(-y.hat),
        dim = -1)
}
```

```{r echo = FALSE}
.model.file <- str_c(fig.dir, "/nn_model.torch")
.train.file <- str_c(fig.dir, "/nn_train.RDS")
.files <- c(.model.file, .train.file)

if.needed(.files,
{

    X <-
        t(read.dense(doublet.data$mtx)) # cell x gene
    is.doublet <-
        function(x) str_detect(x, "[+]")
    y <-
        .readv(doublet.data$col) %>%
        sapply(is.doublet) %>%
        as.numeric %>%
        as.matrix

    xx <- torch_tensor(X)
    yy <- torch_tensor(y)
    nn <- nrow(xx)
    p <- ncol(xx)
    k.fold <- 5

    .test <- which(sample(k.fold, nn, replace=TRUE) == 1)
    .train <- setdiff(1:nn, .test)
    n.test <- length(.test)
    n.train <- length(.train)

    y.model <- build.classifier(p)
    opt <- optim_adam(y.model$parameters, lr = 1e-2)
    batch.size <- 100

    max.iter <- 500
    train.loss.vec <- rep(NA, max.iter)
    test.loss.vec <- rep(NA, max.iter)

    for(ii in 1:max.iter){
        .rand <- .train[sample(n.train, batch.size)]
        xx.b <- xx[.rand, ]
        yy.b <- yy[.rand, ]
        opt$zero_grad()
        y.hat <- y.model(xx.b)
        loss <- torch_mean(-llik(y.hat, yy.b))
        loss$backward()
        opt$step()

        .rand <- .test[sample(n.test, batch.size)]
        xx.b <- xx[.rand, ]
        yy.b <- yy[.rand, ]
        y.hat <- y.model(xx.b)
        loss.test <- torch_mean(-llik(y.hat, yy.b))

        train.loss.vec[ii] <- loss$item()
        test.loss.vec[ii] <- loss.test$item()
        cat("iter: ", ii,
            ", train:", train.loss.vec[ii],
            ", test:", test.loss.vec[ii],
            "\r")
    }

    total.pred <- as.numeric(y.model(xx))
    torch_save(y.model, .model.file)
    saveRDS(list(train.loss = train.loss.vec,
                 test.loss = test.loss.vec,
                 pred = total.pred),
            .train.file)

})
```

```{r fig.width=2.2, fig.height=2, only.plot="2"}
train.result <- readRDS(.train.file)
.dt <-
    data.table(train = train.result$train.loss,
               test = train.result$test.loss) %>%
    mutate(iteration = 1:n()) %>%
    melt(id.vars = "iteration", value.name="-log-likelihood") %>%
    arrange(`-log-likelihood`)

.aes <- aes(`iteration`, `-log-likelihood`, shape=variable, colour=variable)

.gg.plot(.dt, .aes) +
    geom_point(stroke=0, alpha=.8) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.2,"lines"))+
    scale_colour_manual(values=c("gray", "gray20"))

```

```{r echo = FALSE}
.class.file <- str_c(fig.dir, "/nn_classification.RDS")
if(!file.exists(.class.file)) {
    y.model <- torch_load(.model.file)
    X <- t(read.dense(raw.data$mtx))
    y <- y.model(torch_tensor(X)) %>%
        as.numeric()
    saveRDS(y, .class.file)
}
y <- readRDS(.class.file)
```

```{r fig.width=2.2, fig.height=2, only.plot=3}
pred.dt <-
    data.table(`name` = .readv(raw.data$col),
               `doublet` = y) %>%
    mutate(dbl.bin = round(`doublet` * 5)/5)

.dt <- eda.out$tsne %>%
    merge(eda.out$cell) %>%
    merge(pred.dt) %>%
    arrange(doublet) %>%
    na.omit

.gg.plot(.dt, aes(V1, V2, fill=`doublet`)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller(palette="YlGnBu",direction=1) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("tSNE1") + ylab("tSNE2")

```

:::
::::::


## The predicted doublets generally correspond to cells with few non-zero elements

:::::: {.columns}
::: {.column width=.45}

```{r fig.width=2.2, fig.height=2}
.aes <- aes(as.factor(dbl.bin), nnz)

.gg.plot(.dt, .aes) +
    ylab("number of non-zero elements") +
    xlab("predicted Pr(doublet)") +
    geom_violin(aes(fill=dbl.bin)) +
    scale_fill_distiller(palette="YlGnBu", direction=1, guide="none") +
    geom_boxplot(width=.1, outlier.stroke = 0, outlier.size = 0)
```

:::
::: {.column width=.45}

```{r fig.width=2.2, fig.height=2}
.aes <- aes(as.factor(dbl.bin), `sd`)

.gg.plot(.dt, .aes) +
    ylab("standard deviation") +
    xlab("predicted Pr(doublet)") +
    geom_violin(aes(fill=dbl.bin)) +
    scale_fill_distiller(palette="YlGnBu", direction=1, guide="none") +
    geom_boxplot(width=.1, outlier.stroke = 0, outlier.size = 0)
```

:::
::::::

Low expression within a cell may stem from unwanted burst-out cells or ambient RNA molecules.

## The predicted doublets generally correspond to cells with few non-zero elements

```{r fig.width=3, fig.height=2.5}

p1 <-
    .gg.plot(.dt, aes(doublet)) +
    theme(axis.text.x = element_blank()) +
    theme(axis.title.x = element_blank()) +
    geom_histogram() +
    geom_vline(xintercept = .75, lty = 2, colour="red", size=.5)

.aes <- aes(doublet, nnz)

p2 <-
    .gg.plot(.dt, .aes) +
    geom_hex(colour="black", size=.1) +
    geom_vline(xintercept = .75, lty = 2, colour="red", size=.5) +
    geom_hline(yintercept = 1000, lty = 2, colour="red", size=.5) +
    scale_fill_distiller(palette="YlGnBu", trans="log10", direction=1) +
    scale_y_log10() +
    theme(legend.position = "right") +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.5,"lines"))+
    ylab("number of non-zero\nelements") +
    xlab("predicted Pr(doublet)")

wrap_plots(p1, p2, heights=c(1, 2))
```

## After removing potential doublets

:::::: {.columns}
::: {.column width=.5}

* All the cells

```{r echo=FALSE, fig.width=2, fig.height=2, only.plot=1}

.gg.plot(.dt, aes(V1, V2, fill=`doublet`)) +
    geom_point(stroke=.1, pch=21, size=1, alpha=.8) +
    scale_fill_distiller(palette="YlGnBu",direction=1, guide="none") +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("tSNE1") + ylab("tSNE2")

```

:::
::: {.column width=.5}

* P(doublet) < .75, \#non-zeros > 1k

```{r echo=FALSE, fig.width=2, fig.height=2}

.gg.plot(.dt[doublet < .75 & nnz > 1000], aes(V1, V2)) +
    geom_point(stroke=.1, colour="gray", size=1, alpha=.8) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("tSNE1") + ylab("tSNE2")

```

:::
::::::



## Maybe it is more than just low expression cells

:::::: {.columns}
::: {.column width=.5}

* \#non-zeros > 1k

```{r echo=FALSE, fig.width=2, fig.height=2.1}

.dt.2 <- .dt %>%
    filter(nnz > 1000) %>%
    mutate(doublet = (doublet > .75)) %>%
    arrange(doublet)

.gg.plot(.dt.2, aes(V1, V2, colour=doublet)) +
    geom_point(stroke=.1, size=1, alpha=.8) +
    scale_colour_manual(values=c("gray", "red")) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("tSNE1") + ylab("tSNE2")

```


:::
::: {.column width=.5}

* P(doublet) < .75, \#non-zeros > 1k

```{r echo=FALSE, fig.width=2, fig.height=2}

.gg.plot(.dt[doublet < .75 & nnz > 1000], aes(V1, V2)) +
    geom_point(stroke=.1, colour="gray", size=1, alpha=.8) +
    theme(legend.position = c(1,1)) +
    theme(legend.justification = c(1,1)) +
    theme(legend.key.width = unit(.2,"lines"))+
    theme(legend.key.height = unit(.3,"lines"))+
    xlab("tSNE1") + ylab("tSNE2")

```

:::
::::::


## Discussion on doublet Q/C

\Large

* It's a unique routine in single-cell sequencing data analysis

* Do we need it in practice? How frequently doublets emerge?

* Perhaps a majority of them simply stem from "dying" cells or broken cells... If so, we can just filter out low-expressed cells.

# Other topics

## Other interesting topics in scRNA-seq analysis

\Large

1. Differential expression analysis

2. RNA velocity and pseudo-time analysis

3. Multiomics data integration

4. Spatial transcriptomics
